#!/bin/bash
#
# mpplus - Run mpcplus and visualizer in separate terminal emulators,
#          or a specified MPD client and visualizer in separate windows.
#
# Written by Ronald Joe Record <ronaldrecord@gmail.com>
# March, 2022
#
# I am using two separate terminal emulators as I want a smaller
# font for the visualizer terminal. The terminal command options are
# customized for my setup, you may need to adjust the geometry
# to get the two windows to align as desired. I wanted the visualizer
# terminal window at the bottom of the screen and aligned with
# the mpcplus terminal window.
#
# If the "-t" option is specified then only a single terminal
# emulator is used, tilix. Tilix is invoked twice with different
# profiles, one for mpcplus and another for the visualizer.
# The profiles are named "MusicPlayer" and "Visualizer". 
#
# In both types of invocations, with or without "-t", the terminal
# profiles used have font sizee settings of 32 and 8 for mpcplus and
# visualizer, respectively. This aligns the windows, on my system, when
# not in fullscreen mode.
#
# When using the cool-retro-term for mpcplus (-r option), adjust the
# size of the cool-retro-term window manually so it aligns with the
# visualizer window. I could not figure out how to specify a geometry
# for the cool-retro-term window when invoked with "-e mpcplus".
#
# An alternate MPD client can be specified on the command line.

BOLD=$(tput bold)
NORM=$(tput sgr0)
PLEASE="Please enter your"
VTITLE="Spectrum Visualizer"
MTITLE="Music Player Plus"
VISUALIZER=mppcava
CONSOLE_MODE=
DO_NOT_EXIT=
FIG_FONTS="/usr/share/figlet-fonts"
FIG_TEXT="MusicPlayerPlus"
USE_FONT="Standard"
USE_GRAD=1
MPP_DIR="/usr/share/musicplayerplus"
DOC_DIR="/usr/share/doc/musicplayerplus"
SCRIPTS="${MPP_DIR}/scripts"
BEETSLOGDIR="${HOME}/.config/beets/logs"
# Some configuration can be maintained here
MPPCONF="${HOME}/.config/mpprc"

usage() {
  printf "\nUsage: mpplus [-A] [-a] [-b] [-B] [-c] [-C client] [-E] [-e] [-F] [-f]"
  printf "\n\t[-G] [-g] [-D art|bandcamp|soundcloud] [-d music_directory] [-h]"
  printf "\n\t[-H] [-I] [-i] [-jJ] [-k] [-K] [-L] [-m] [-n num] [-N]"
  printf "\n\t[-M alsaconf|enable|disable|restart|start|stop|status] [-p]"
  printf "\n\t[-P script] [-q] [-r] [-R] [-s song] [-S] [-t] [-T on|off] [-uU]"
  printf "\n\t[-v viz_comm] [-w|W] [-x query] [-X query] [-y] [-Y] [-z fzmpopt]"
  printf "\nMPCplus/Visualizer options:"
  printf "\n\t-A indicates display album cover art (implies tmux session)"
  printf "\n\t-C 'client' indicates use 'client' MPD client rather than mpcplus"
  printf "\n\t-E indicates do not use gradient colors for spectrum visualizer"
  printf "\n\t-f indicates fullscreen display"
  printf "\n\t-h indicates half-height for visualizer window (with -f only)"
  printf "\n\t-H indicates disable use of extended window manager hints"
  printf "\n\t-P script specifies the ASCIImatics script to run in visualizer pane"
  printf "\n\t-q indicates quarter-height for visualizer window (with -f only)"
  printf "\n\t-c indicates use current terminal emulator / console mode"
  printf "\n\t-e indicates use simple terminal emulator"
  printf "\n\t-g indicates use gnome terminal emulator"
  printf "\n\t-k indicates use kitty terminal emulator"
  printf "\n\t-r indicates use retro terminal emulator"
  printf "\n\t-t indicates use tilix terminal emulator"
  printf "\n\t-U indicates use tmuxp to create tmux sessions"
  printf "\n\t-v 'viz_comm' indicates use visualizer 'viz_comm' rather than mppcava"
  printf "\nASCIImatics animation options:"
  printf "\n\t-a indicates play audio during ASCIImatics display"
  printf "\n\t-b indicates use backup audio during ASCIImatics display"
  printf "\n\t-j indicates use Julia Set scenes in ASCIImatics display"
  printf "\n\t-J indicates Julia Set with several runs using different parameters"
  printf "\n\t-m indicates use MusicPlayerPlus scenes in ASCIImatics display"
  printf "\n\t-n num specifies the number of times to cycle ASCIImatics scenes"
  printf "\n\t-N indicates use alternate comments in Plasma ASCIImatics scenes"
  printf "\n\t-p indicates use Plasma scenes in ASCIImatics display"
  printf "\n\t-s song specifies a song to accompany an ASCIImatics animation"
  printf "\n\t\t'song' can be the full pathname to an audio file or a"
  printf "\n\t\trelative pathname to an audio file in the MPD music library"
  printf "\n\t\tor $HOME/Music/"
  printf "\n\t-S indicates display ASCIImatics splash animation"
  printf "\nGeneral options:"
  printf "\n\t-B indicates analyze MPD music dir with Blissify and exit"
  printf "\n\t-D 'art' indicates download album cover art and exit"
  printf "\n\t-D 'bandcamp' indicates download Bandcamp songs and exit"
  printf "\n\t-D 'soundcloud' indicates download Soundcloud songs and exit"
  printf "\n\t-d 'music_directory' specifies the music directory to use for"
  printf "\n\t\tdownloaded album cover art. Without this option -D will use"
  printf "\n\t\tthe 'MUSIC_DIR' setting in '~/.config/mpprc'"
  printf "\n\t-F indicates convert WAV format files in the music library"
  printf "\n\t\tto MP3 format files and exit. A subsequent 'mpplus -I' import"
  printf "\n\t\twill be necessary to import these newly converted music files."
  printf "\n\t-G indicates convert M4A format files in the music library"
  printf "\n\t\tto MP3 format files and exit. A subsequent 'mpplus -I' import"
  printf "\n\t\twill be necessary to import these newly converted music files."
  printf "\n\t-I indicates import albums and songs from 'music_directory' to beets and exit"
  printf "\n\t\tIn conjunction with '-I', the '-A' flag disables auto-tagging"
  printf "\n\t-i indicates start mpplus in interactive mode"
  printf "\n\t-K indicates kill MusicPlayerPlus tmux sessions and ASCIImatics scripts"
  printf "\n\t-L indicates download lyrics to the Beets library and exit"
  printf "\n\t-M 'action' can be used to control the Music Player Daemon (MPD)"
  printf "\n\t    or configure the ALSA sound system"
  printf "\n\t\tALSA configuration will update the ALSA configuration in '/etc/asound.conf'"
  printf "\n\t-R indicates record tmux session with asciinema"
  printf "\n\t\tAsciinema is not installed by MusicPlayerPlus"
  printf "\n\t\tTo record tmux sessions with asciinema, use your system's"
  printf "\n\t\tpackage manager to install it (e.g. apt install asciinema)"
  printf "\n\t-T 'on|off' specifies whether to use a tmux session"
  printf "\n\t-w indicates write metadata during beets import"
  printf "\n\t-W indicates do not write metadata during beets import"
  printf "\n\t-x 'query' uses AcousticBrainz to retrieve audio-based information"
  printf "\n\t\tfor all music library media matching 'query'. A query"
  printf "\n\t\tof 'all' performs the retrieval on the entire music library."
  printf "\n\t-X 'query' performs an analysis and retrieval, using Essentia,"
  printf "\n\t\tof audio-based information for all music library media"
  printf "\n\t\tmatching 'query'. A query of 'all' performs the analysis"
  printf "\n\t\tand retrieval on the entire music library."
  printf "\n\t-Y initializes the YAMS last.fm scrobbler service"
  printf "\n\t-y disables the YAMS last.fm scrobbler service"
  printf "\n\t-z fzmpopt specifies the fzmp option and invokes fzmp to"
  printf "\n\t\tlist/search/select media in the MPD library."
  printf "\n\t\tValid values for fzmpopt are 'a', 'A', 'g', 'p', or 'P'"
  printf "\n\t-u displays this usage message and exits\n"
  printf "\nType 'man mpplus' for detailed usage info on mpplus"
  printf "\nType 'man mpcplus' for detailed usage info on the mpcplus MPD client"
  printf "\nType 'man mppsplash' for detailed usage info on the mppsplash command\n"
  exit 1
}

is_running() {
  svc=$1
  [ "${svc}" ] || return 1
  if [ "${svc}" == "mpd" ]
  then
    pgrep "mpd" &> /dev/null
    if [ $? -eq 0 ]
    then
      return 0
    else
      pgrep "mopidy" &> /dev/null
      if [ $? -eq 0 ]
      then
        return 0
      else
        systemctl --user is-active mpd.socket > /dev/null 2>&1
        return $?
      fi
    fi
  else
    pgrep "${svc}" &> /dev/null
    return $?
  fi
}

prompt_for_url() {
  local url
  if [ "$1" == "youtube" ]
  then
    printf "\nEnter a YouTube URL you wish to list."
  else
    printf "\nEnter a URL that contains audio you wish to extract and download."
    printf "\nThis can be a YouTube video URL, a YouTube playlist URL,"
    printf "\nor any URL from many supported sites."
  fi
  printf "\n\nTo cancel and return to menus, enter nothing and press 'Enter'\n\n"
  read -r -e -p 'Enter URL: ' url
  DL_URL="${url}"
}

prompt_for_user() {
  local user
  printf "\nEnter a YouTube user name."
  printf "\n\nTo cancel and return to menus, enter nothing and press 'Enter'\n\n"
  read -r -e -p 'Enter YouTube Username: ' user
  YT_USER="${user}"
}

kill_tmux_sessions() {
  SESSIONS="musicplayerplus mppsplash"
  for session in ${SESSIONS}
  do
    ps -ef | grep tmux | grep ${session} > /dev/null && {
      tmux kill-session -t ${session}
    }
  done
  ASCIIS="mppjulia mpprocks mppplasma"
  for ascii in ${ASCIIS}
  do
    ps -ef | grep -v grep | grep ${ascii} > /dev/null && {
      ps -ef | grep -v grep | grep ${ascii} | while IFS= read -r line
      do
        pid=`echo "$line" | awk ' { print $2 } '`
        kill ${pid}
      done 
    }
  done
}

center_window() {
  kit_win="$1"
  position="$2"
  read -r winid grav width height \
    < <(echo ${kit_win} | awk ' { print $1, $2, $5, $6} ')
  [ "${winid}" ] && {
    xoff=$((s_wid - width))
    xoff=$((xoff / 2))
    if [ "${position}" == "bottom" ]
    then
      vhit=${height}
      yoff=$((s_hit - height))
    else
      if [ "${position}" == "top" ]
      then
        yoff=0
      else
        toff=$((s_hit - position))
        [ "${KITTY}" ] || [ "${SIMPLE}" ] && toff=$((toff - 150))
        yoff=$((toff - height))
        [ ${toff} -lt 0 ] && {
          height=${toff}
          yoff=0
        }
      fi
    fi
    mvarg="${grav},${xoff},${yoff},${width},${height}"
    wmctrl -i -r "${winid}" -b "remove,fullscreen,maximized_vert"
    wmctrl -i -r "${winid}" -e "${mvarg}"
  }
}

pick_terminal() {
  if [ "${have_kitty}" ]
  then
    echo "Continuing with Kitty as the terminal emulator."
    KITTY=1
  else
    if [ "${have_gnome}" ]
    then
      echo "Continuing with gnome-terminal as the terminal emulator."
      GNOME=1
    else
      if [ "${have_tilix}" ]
      then
        echo "Continuing with tilix as the terminal emulator."
        TILIX=1
      else
        if [ "${have_retro}" ]
        then
          echo "Continuing with cool-retro-term as the terminal emulator."
          RETRO=1
        else
          if [ "${have_simple}" ]
          then
            echo "Continuing with st as the terminal emulator."
            SIMPLE=1
          else
            echo "No supported terminal emulator located."
            return 1
          fi
        fi
      fi
    fi
  fi
  return 0
}

make_it_so() {
  [ "${CONVERT_M4A}" ] && {
    if [ -x ${SCRIPTS}/m4a2mp3.sh ]
    then
      printf "\nConverting M4A files\n"
      if [ "${MUSIC_DIRECTORY}" ]
      then
        ${SCRIPTS}/m4a2mp3.sh -d "${MUSIC_DIRECTORY}"
      else
        ${SCRIPTS}/m4a2mp3.sh
      fi
    else
      echo "${SCRIPTS}/m4a2mp3.sh not found or not executable"
      echo "Check your MusicPlayerPlus installation"
      echo ""
      echo "Manual media file conversion may be required"
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }
  [ "${CONVERT_WAV}" ] && {
    if [ -x ${SCRIPTS}/wav2mp3.sh ]
    then
      printf "\nConverting WAV files\n"
      if [ "${MUSIC_DIRECTORY}" ]
      then
        ${SCRIPTS}/wav2mp3.sh -d "${MUSIC_DIRECTORY}"
      else
        ${SCRIPTS}/wav2mp3.sh
      fi
    else
      echo "${SCRIPTS}/wav2mp3.sh not found or not executable"
      echo "Check your MusicPlayerPlus installation"
      echo ""
      echo "Manual media file conversion may be required"
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${DOWNLOAD_ART}" ] && {
    [ -f "${HOME}/.config/beets/logs/import.log" ] && {
      [ "${have_beet}" ] && {
        printf "\n\tDownloading album cover art with Beets fetchart ..."
        beet fetchart ${MUSIC_DIR} > /dev/null 2>&1
        printf " done\n\n"
      }
    }
    if [ -x ${SCRIPTS}/download_cover_art.sh ]
    then
      printf "\n\tDownloading album cover art with sacad ..."
      if [ "${MUSIC_DIRECTORY}" ]
      then
        ${SCRIPTS}/download_cover_art.sh -d "${MUSIC_DIRECTORY}"
      else
        ${SCRIPTS}/download_cover_art.sh
      fi
      printf "\n\n"
    else
      echo "${SCRIPTS}/download_cover_art.sh not found or not executable"
      echo "Check your MusicPlayerPlus installation"
      echo ""
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${DOWNLOAD_BANDCAMP}" ] && {
    mppinit bandcamp
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${DOWNLOAD_SOUNDCLOUD}" ] && {
    mppinit soundcloud
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${DOWNLOAD_YOUTUBE}" ] && {
    [ "${DL_URL}" ] || prompt_for_url
    [ "${DL_URL}" ] && mppdl "${DL_URL}"
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${LIST_YT_PLAYLISTS}" ] && {
    [ "${YT_USER}" ] || prompt_for_user
    [ "${YT_USER}" ] && listyt -p "${YT_USER}" | less
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${LIST_YT_UPLOADS}" ] && {
    [ "${YT_USER}" ] || prompt_for_user
    [ "${YT_USER}" ] && listyt -v "${YT_USER}" | less
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${LIST_YT_URL}" ] && {
    [ "${DL_URL}" ] || prompt_for_url youtube
    [ "${DL_URL}" ] && listyt "${DL_URL}" | less
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${ACT_YAMS}" ] && {
    if [ "${need_yams}" ]
    then
      YAMSCOMM=
      have_yams=`type -p yams`
      if [ "${have_yams}" ]
      then
        YAMSCOMM=yams
      else
        [ -x ${HOME}/.local/bin/yams ] && {
          YAMSCOMM="${HOME}/.local/bin/yams"
        }
      fi
      if [ "${YAMSCOMM}" ]
      then
        printf "\n\tInitializing YAMS last.fm scrobbler service\n"
        printf "\n\tOpen the token URL to authenticate with Last.fm\n\n"
        ${YAMSCOMM} -k > /dev/null 2>&1
        ${YAMSCOMM}
        ${YAMSCOMM} -k > /dev/null 2>&1
        if [ -f "${HOME}/.config/yams/yams.yml" ]
        then
          need_yams=
        else
          need_yams=1
        fi
        if [ "${need_yams}" ]
        then
          echo "YAMS not activated."
          echo "Activate YAMS manually by executing the command 'yams'."
        else
          # Prepare the yams scrobbler user service for later activation
          systemctl --user is-active --quiet yams.service
          if [ $? -eq 0 ]
          then
            # User service is active, restart to pickup any config changes
            systemctl --user restart --quiet yams.service
          else
            systemctl --user start --quiet yams.service
          fi
          systemctl --user is-enabled --quiet yams.service
          [ $? -eq 0 ] || systemctl --user enable --quiet yams.service
          echo ""
          echo "YAMS Last.fm scrobbler activated and running as a service."
          echo "Music played with MusicPlayerPlus should be reflected"
          echo "in your Last.fm account statistics."
          echo ""
          echo "To disable YAMS run the command 'mpplus -y'."
          echo ""
        fi
      else
        echo "The yams front-end not found or not executable."
        echo "Check your MusicPlayerPlus installation."
        echo "Yams can be installed with the command:"
        echo "    python3 -m pip install YAMScrobbler"
        echo ""
      fi
      [ "${DO_NOT_EXIT}" ] || exit 0
      return
    else
      echo "A YAMS service has been detected."
      echo "This may indicate YAMS has already been activated."
      echo "To re-activate YAMS, disable and de-activate the YAMS service:"
      echo "    systemctl --user disable yams.service"
      echo "    systemctl --user stop yams.service"
      echo "and re-run the command 'mpplus -Y'"
      [ "${DO_NOT_EXIT}" ] || exit 0
      return
    fi
  }

  [ "${DIS_YAMS}" ] && {
    # Disable YAMS service
    echo "Disabling YAMS Last.fm scrobbler service"
    echo "and removing YAMS configuration $HOME/.config/yams/"
    while true
    do
      read -p "Continue to disable and remove YAMS configuration ? (y/n) " yn
      case $yn in
        [Yy]* )
              systemctl --user disable yams.service
              systemctl --user stop yams.service
              rm -rf ${HOME}/.config/yams
              printf "\n\nYAMS disabled and configuration removed."
              printf "\nTo re-enable YAMS run the command 'mpplus -Y'.\n"
              exit 0
              ;;
        [Nn]* )
              printf "\n\nYAMS service left as-is, no changes made."
              printf "\nExiting.\n"
              exit 0
              ;;
            * ) echo "Please answer yes or no."
              ;;
      esac
    done
  }

  [ "${FETCH_LYRICS}" ] && {
    if [ "${have_beet}" ]
    then
      echo ""
      echo "===================================================================="
      echo "Fetching lyrics for all songs in the music library which do not"
      echo "already contain lyrics. This can take several minutes or hours"
      echo "depending on how many songs need lyrics."
      echo ""
      echo "The process is performed in the background and non-interactively."
      echo "As long as your computer remains on and connected to the Internet, the"
      echo "process should run uninterrupted and without need for attention."
      echo "You may continue working and leave the lyrics update unattended."
      echo ""
      [ -d "${BEETSLOGDIR}" ] || mkdir -p "${BEETSLOGDIR}"
      LLOG="${BEETSLOGDIR}/lyrics.log"
      nohup beet lyrics >> ${LLOG} 2>&1 &
      beetpid=$!
      if [ "${CONSOLE_MODE}" ]
      then
        echo "To monitor the progress of the lyrics downloads, examine the log:"
        echo ""
        echo "tail -f ${LLOG}"
      else
        echo "A terminal window will be opened to monitor the progress."
        echo ""
        # gnome-terminal --title="Beets Lyrics Log" --geometry=90x25+50+25 \
        #                -- tail --pid=${beetpid} -f ${LLOG} &
        kitty --title="Beets Lyrics Log" tail --pid=${beetpid} -f ${LLOG} &
      fi
      echo "===================================================================="
      echo ""
    else
      echo "The 'beet' command is not in your PATH or is not executable."
      echo "Check your MusicPlayerPlus installation."
      echo "Once the 'beet' command is executable and in the execution PATH,"
      echo "Re-run this command."
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${ACBRAINZ}" ] && {
    if [ "${have_beet}" ]
    then
      echo ""
      echo "==================================================================="
      echo "Retrieving audio-based information for media matching '${ACBRAINZ}'"
      echo "in the Beets music library management system. The retrieval can"
      echo "take a few seconds or more per album. A large music library may"
      echo "take hours to retrieve all the metadata."
      echo ""
      echo "The process is performed in the background and non-interactively."
      echo "As long as your computer remains on and connected to the Internet,"
      echo "the process should run uninterrupted and without need for attention."
      echo "You may continue working and leave the extraction unattended."
      echo ""
      if [ "${ACBRAINZ}" == "all" ]
      then
        extquery=
      else
        extquery="${ACBRAINZ}"
      fi
      [ -d "${BEETSLOGDIR}" ] || mkdir -p "${BEETSLOGDIR}"
      XLOG="${BEETSLOGDIR}/acousticbrainz.log"
      echo "# Retrieving audio metadata with acousticbrainz plugin" >> "${XLOG}"
      START_SECONDS=$(date +%s)
      if [ "${extquery}" ]
      then
        nohup beet -v --plugins=acousticbrainz acousticbrainz ${extquery} >> ${XLOG} 2>&1 &
      else
        ${SCRIPTS}/ab_albums.sh "${XLOG}" &
      fi
      beetpid=$!
      [ -x ${SCRIPTS}/logtime.sh ] && {
        ${SCRIPTS}/logtime.sh -s "${START_SECONDS}" -l "${XLOG}" \
                              -p "${beetpid}" -d "Acoustic retrieval" 2>&1 &
      }
      if [ "${CONSOLE_MODE}" ]
      then
        echo "To monitor the progress of the acoustic metadata retrieval,"
        echo "examine the extraction log:"
        echo ""
        echo "tail -f ${XLOG}"
      else
        echo "A terminal window will be opened to monitor the progress"
        echo "of the acoustic metadata retrieval."
        # gnome-terminal --title="AcousticBrainz Log" --geometry=90x25+50+25 \
        #                -- tail --pid=${beetpid} -f ${XLOG} &
        kitty --title="AcousticBrainz Log" tail --pid=${beetpid} -f ${XLOG} &
      fi
      echo ""
      echo "The AcousticBrainz service is depracated and no longer updated."
      echo "To augment acoustic metadata, run '${BOLD}mpplus -X all${NORM}' or"
      echo "'${BOLD}mpplus -X bpm:0${NORM}' after this retrieval is completed"
      echo "==================================================================="
    else
      echo "The 'beet' command is not in your PATH or is not executable."
      echo "Check your MusicPlayerPlus installation."
      echo "Once the 'beet' command is executable and in the execution PATH,"
      echo "Re-run this command."
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${BLISSIFY}" ] && {
    have_bliss=`type -p blissify`
    if [ "${have_bliss}" ]
    then
      echo ""
      echo "==========================================================================="
      echo "Performing audio analysis and audio-based information retrieval for media"
      echo "in the Music Player Daemon (MPD) music directory with Blissify."
      echo "The analysis and retrieval can take a minute or so per album."
      echo "A large music library may take several hours to extract."
      echo ""
      echo "The process is performed in the background and non-interactively."
      echo "As long as your computer remains on and connected to the Internet,"
      echo "the process should run uninterrupted and without need for attention."
      echo "You may continue working and leave the extraction unattended."
      echo ""
      MPDLOGDIR="${HOME}/.config/mpd"
      [ -d "${MPDLOGDIR}" ] || mkdir -p "${MPDLOGDIR}"
      XLOG="${MPDLOGDIR}/blissify.log"

      MPD_CONF="${MPDLOGDIR}/mpd.conf"
      mpd_music=`grep ^music_directory ${MPD_CONF}`
      mpd_music=`echo ${mpd_music} | awk ' { print $2 } ' | sed -e "s/\"//g"`
      [ "${mpd_music}" ] || mpd_music="${HOME}/Music"
      # Need to expand the tilda to $HOME
      mpd_music="${mpd_music/#\~/$HOME}"

      [ "${MPD_HOST}" ] || {
        mpd_host=`grep ^bind_to_address ${MPD_CONF}`
        mpd_host=`echo ${mpd_host} | awk ' { print $2 } ' | sed -e "s/\"//g"`
        [ "${mpd_host}" ] || mpd_host="localhost"
        MPD_HOST="${mpd_host}"
      }
      [ "${MPD_PORT}" ] || {
        mpd_port=`grep ^port ${MPD_CONF}`
        mpd_port=`echo ${mpd_port} | awk ' { print $2 } ' | sed -e "s/\"//g"`
        [ "${mpd_port}" ] || mpd_port="6600"
        MPD_PORT="${mpd_port}"
      }
      export MPD_HOST MPD_PORT

      echo "# Extracting audio metadata with Blissify" >> "${XLOG}"
      START_SECONDS=$(date +%s)
      nohup blissify update "${mpd_music}" >> ${XLOG} 2>&1 &
      blisspid=$!
      [ -x ${SCRIPTS}/logtime.sh ] && {
        ${SCRIPTS}/logtime.sh -s "${START_SECONDS}" -l "${XLOG}" \
                  -p "${blisspid}" -d "Blissify acoustic extraction" 2>&1 &
      }
      if [ "${CONSOLE_MODE}" ]
      then
        echo "To monitor the progress of the extraction, examine the extraction log:"
        echo ""
        echo "tail -f ${XLOG}"
      else
        echo "A terminal window will be opened to monitor the progress of the extraction."
        # gnome-terminal --title="Blissify Extraction Log" \
        #                --geometry=90x25+50+25 \
        #                -- tail --pid=${blisspid} -f ${XLOG} &
        kitty --title="Blissify Extraction Log" \
                       tail --pid=${blisspid} -f ${XLOG} &
      fi
      echo "==========================================================================="
    else
      echo "The 'blissify' command is not in your PATH or is not executable."
      echo "Check your MusicPlayerPlus installation."
      echo "(Blissify is currently unavailable on Raspberry Pi installs)"
      echo "Once the 'blissify' command is executable and in the execution PATH,"
      echo "Re-run this command."
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${XTRACTOR}" ] && {
    if [ "${have_beet}" ]
    then
      echo ""
      echo "==========================================================================="
      echo "Performing audio analysis and audio-based information retrieval for media"
      echo "matching '${XTRACTOR}' in the Beets music library management system."
      echo "The analysis and retrieval can take a minute or so per album."
      echo "A large music library may take several hours to extract."
      echo ""
      echo "The process is performed in the background and non-interactively."
      echo "As long as your computer remains on and connected to the Internet,"
      echo "the process should run uninterrupted and without need for attention."
      echo "You may continue working and leave the extraction unattended."
      echo ""
      if [ "${XTRACTOR}" == "all" ]
      then
        extquery=
      else
        extquery="${XTRACTOR}"
      fi
      [ -d "${BEETSLOGDIR}" ] || mkdir -p "${BEETSLOGDIR}"
      XLOG="${BEETSLOGDIR}/xtractor.log"
      echo "# Extracting audio metadata with xtractor plugin" >> "${XLOG}"
      START_SECONDS=$(date +%s)
      nohup beet -v --plugins=xtractor xtractor ${extquery} >> ${XLOG} 2>&1 &
      beetpid=$!
      [ -x ${SCRIPTS}/logtime.sh ] && {
        ${SCRIPTS}/logtime.sh -s "${START_SECONDS}" -l "${XLOG}" \
                              -p "${beetpid}" -d "Acoustic extraction" 2>&1 &
      }
      if [ "${CONSOLE_MODE}" ]
      then
        echo "To monitor the progress of the extraction, examine the extraction log:"
        echo ""
        echo "tail -f ${XLOG}"
      else
        echo "A terminal window will be opened to monitor the progress of the extraction."
        # gnome-terminal --title="Beets Extraction Log" --geometry=90x25+50+25 \
        #                -- tail --pid=${beetpid} -f ${XLOG} &
        kitty --title="Beets Extraction Log" tail --pid=${beetpid} -f ${XLOG} &
      fi
      echo "==========================================================================="
    else
      echo "The 'beet' command is not in your PATH or is not executable."
      echo "Check your MusicPlayerPlus installation."
      echo "Once the 'beet' command is executable and in the execution PATH,"
      echo "Re-run this command."
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  [ "${BEETS_IMPORT}" ] && {
    if [ -x ${SCRIPTS}/beet_import.sh ]
    then
      echo ""
      echo "===================================================================="
      echo "Importing, tagging, and organizing your music library with the Beets"
      echo "media library management system. A large music library may require"
      echo "several hours to fully complete the import process."
      echo ""
      echo "The import process is performed in the background and non-interactively."
      echo "As long as your computer remains on and connected to the Internet, the"
      echo "import process should run uninterrupted and without need for attention."
      echo "You may continue working and leave the import unattended."
      echo ""

      [ -d "${BEETSLOGDIR}" ] || mkdir -p "${BEETSLOGDIR}"
      if [ "${MUSIC_DIRECTORY}" ]
      then
        nohup ${SCRIPTS}/beet_import.sh ${impflags} -d "${MUSIC_DIRECTORY}" > /dev/null 2>&1 &
      else
        nohup ${SCRIPTS}/beet_import.sh ${impflags} > /dev/null 2>&1 &
      fi
      beetpid=$!
      if [ "${CONSOLE_MODE}" ]
      then
        echo "To monitor the progress of the import, examine the import log:"
        echo ""
        echo "tail -f $BEETSLOGDIR/import_time.log"
      else
        echo "A terminal window will be opened to monitor the progress of the import."
        echo ""
        echo "Beets log files can be found in $BEETSLOGDIR"
        # gnome-terminal --title="Beets Import Log" --geometry=90x25+50+25 \
        #        -- tail --pid=${beetpid} -f ${BEETSLOGDIR}/import_time.log &
        kitty --title="Beets Import Log" \
              tail --pid=${beetpid} -f ${BEETSLOGDIR}/import_time.log &
      fi
      have_hostname=`type -p hostname`
      if [ "${have_hostname}" ]
      then
        IP=`hostname -I | awk '{print $1}'`
      else
        have_ip=`type -p ip`
        if [ "${have_ip}" ]
        then
          IP=`ip route get 1.2.3.4 | head -1 | awk '{print $7}'`
        else
          IP="<ip address>"
        fi
      fi
      printf "\n\nWhen the import has completed, "
      printf "visit the Beets web interface at:"
      printf "\n\thttp://${IP}:8337\n" 
      echo "===================================================================="
    else
      echo "${SCRIPTS}/beet_import.sh not found or not executable"
      echo "Check your MusicPlayerPlus installation"
      echo ""
      echo "Manual beets import may be required:"
      printf "\n\tbeet import -[w|W] <MUSIC_DIRECTORY>"
      printf "\n\tbeet import -[w|W]ps <MUSIC_DIRECTORY>"
      printf "\nWhere <MUSIC_DIRECTORY> is the full pathname to your music library,"
      printf "\n-w indicates write metadata, -W indicates do not write metadata\n"
    fi
    [ "${DO_NOT_EXIT}" ] || exit 0
    return
  }

  # Check if MPD or Mopidy is active before starting mppcava and mpcplus
  is_running mpd || {
    if systemctl --user is-active navidrome.service >/dev/null 2>&1
    then
      DO_NOT_EXIT=1
      show_main_menu
    else
      printf "\n\nRequired MPD"
      [ "${have_mopidy}" ] && printf " or Mopidy"
      printf " service is not active."
      printf "\nStart the MPD service with the command:"
      printf "\n\tmpplus -M start"
      [ "${have_mopidy}" ] && {
        printf "\nAlternatively, start the Mopidy service with the command:"
        printf "\n\tsystemctl --user start mopidy.service"
      }
      printf "\nRe-run 'mpplus' to start the MPD client and visualizer.\n\n"
      read -p "Press Enter to continue to MusicPlayerPlus menus " yn
      DO_NOT_EXIT=1
      show_main_menu
    fi
  }

  # In fullscreen mode terminals without transparency use tmux
  [ "${FULLSCREEN}" ] && {
    [ "${SIMPLE}" ] && TMUX_MPC=1
    [ "${USE_OPAC}" ] || TMUX_MPC=1
  }
  # Always use tmux in cool-retro-term
  [ "${RETRO}" ] && TMUX_MPC=1

  # Begin visualizer startup section
  #
  # Do not start visualizer here if we are going to start a tmux session,
  # if we are displaying an asciimatics animation, or using cool-retro-term.
  [ "${TMUX_MPC}" ] || [ "${SPLASH}" ] || {
    if [ "${FULLSCREEN}" ]
    then
      if [ "${KITTY}" ]
      then
        QRTRHEIGHT=1
        kitty --title "${VTITLE}" \
              --start-as fullscreen \
              --override font_size=8 \
              --override background_opacity=1.0 \
              --override hide_window_decorations=yes \
              --override tab_bar_min_tabs=2 \
              ${VISUALIZER} 2> /dev/null &
      else
        if [ "${TILIX}" ]
        then
          tilix --title="${VTITLE}" \
                --full-screen \
                --window-style=borderless \
                --profile=Visualizer \
                --command="${VISUALIZER}" 2> /dev/null &
        else
          if [ "${GNOME}" ]
          then
            gnome-terminal --title="${VTITLE}" \
                  --profile=Visualizer \
                  --hide-menubar \
                  --full-screen \
                  -- ${VISUALIZER} &
          else
            # No supported terminal emulator available, use tmux
            TMUX_MPC=1
          fi
        fi
      fi
      viz_win=
      [ "${HALFHEIGHT}" ] || [ "${QRTRHEIGHT}" ] && {
        [ "${USE_EWMH}" ] && {
          sleep 1
          if [ "${KITTY}" ]
          then
            viz_win=`wmctrl -l -G -x | grep kitty.kitty | \
              grep "${VTITLE}"`
          else
            if [ "${TILIX}" ]
            then
              viz_win=`wmctrl -l -G -x | grep tilix.Tilix | \
                grep "${VTITLE}"`
            else
              if [ "${GNOME}" ]
              then
                viz_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                  grep "${VTITLE}"`
              else
                [ "${SIMPLE}" ] && {
                  viz_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                    grep "${VTITLE}"`
                }
              fi
            fi
          fi
          [ "${viz_win}" ] || {
            if [ "${KITTY}" ]
            then
              viz_win=`wmctrl -l -G -x | grep kitty.kitty | \
                grep "${VISUALIZER}"`
            else
              if [ "${TILIX}" ]
              then
                viz_win=`wmctrl -l -G -x | grep tilix.Tilix | \
                  grep "${VISUALIZER}"`
              else
                if [ "${GNOME}" ]
                then
                  viz_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                    grep "${VISUALIZER}"`
                else
                  [ "${SIMPLE}" ] && {
                    viz_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                      grep "${VISUALIZER}"`
                  }
                fi
              fi
            fi
          }
          if [ "${viz_win}" ]
          then
            read -r winid grav xoff yoff width height \
              < <(echo ${viz_win} | awk ' { print $1, $2, $3, $4, $5, $6} ')
            [ "${winid}" ] && {
              if [ "${HALFHEIGHT}" ]
              then
                height=$((height / 2))
              else
                height=$((height / 4))
                # Fudge this to compensate for differing window decoration size
                [ "${TILIX}" ] || height=$((height - 30))
                [ "${KITTY}" ] && height=$((height - 75))
                [ ${height} -lt 70 ] && height=70
              fi
              mvarg="${grav},${xoff},${yoff},${width},${height}"
              wmctrl -i -r "${winid}" -b "remove,fullscreen,maximized_vert"
              wmctrl -i -r "${winid}" -e "${mvarg}"
            }
          else
            echo "Could not find visualizer window"
          fi
        }
      }
    else
      vhit=0
      if [ "${KITTY}" ]
      then
        kitty --title="${VTITLE}" \
              --start-as normal \
              --override font_size=8 \
              --override initial_window_width=240c \
              --override initial_window_height=12c \
              --override tab_bar_min_tabs=2 \
              --single-instance \
              ${VISUALIZER} 2> /dev/null &
        [ "${USE_EWMH}" ] && {
          sleep 1
          kit_win=`wmctrl -l -G -x | grep kitty.kitty | grep "${VTITLE}"`
          [ "${kit_win}" ] || {
            kit_win=`wmctrl -l -G -x | grep kitty.kitty | grep "${VISUALIZER}"`
          }
          [ "${kit_win}" ] && center_window "${kit_win}" bottom
        }
      else
        if [ "${TILIX}" ]
        then
          tilix --title="${VTITLE}" \
                --window-style=borderless \
                --geometry=390x16+150-0 \
                --profile=Visualizer \
                --command="${VISUALIZER}" 2> /dev/null &
          [ "${USE_EWMH}" ] && {
            sleep 1
            til_win=`wmctrl -l -G -x | grep tilix.Tilix | grep "${VTITLE}"`
            [ "${til_win}" ] || {
              til_win=`wmctrl -l -G -x | grep tilix.Tilix | grep "${VISUALIZER}"`
            }
            [ "${til_win}" ] && center_window "${til_win}" bottom
          }
        else
          if [ "${GNOME}" ]
          then
            gnome-terminal --title="${VTITLE}" \
                  --profile=Visualizer \
                  --hide-menubar \
                  --geometry 390x16+150-0 \
                  -- ${VISUALIZER} &
            [ "${USE_EWMH}" ] && {
              sleep 1
              gno_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                grep "${VTITLE}"`
              [ "${gno_win}" ] || {
                gno_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                  grep "${VISUALIZER}"`
              }
              [ "${gno_win}" ] && center_window "${gno_win}" bottom
            }
          else
            if [ "${SIMPLE}" ]
            then
              st -t "${VTITLE}" \
                 -g "190x12+50-0" \
                 -f "Monospace:size=12" \
                 ${VISUALIZER} 2> /dev/null &
              [ "${USE_EWMH}" ] && {
                sleep 1
                stl_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                                           grep "${VTITLE}"`
                [ "${stl_win}" ] || {
                  stl_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                                             grep "${VISUALIZER}"`
                }
                [ "${stl_win}" ] && center_window "${stl_win}" bottom
              }
            else
              # No supported terminal emulator available, use tmux
              TMUX_MPC=1
            fi
          fi
        fi
      fi
    fi
  }
  # End visualizer startup section

  # TODO: handle other graphical mpd clients
  # [ "${MPCPLUS}" == "cantata" ] && {
  #   COVER_ART=
  #   CURRENT=
  #   FULLSCREEN=
  #   GNOME=
  #   KITTY=
  #   RETRO=
  #   SIMPLE=
  #   TILIX=
  #   TMUX_MPC=
  #   USE_TMUX=
  # }
  # Fullscreen ASCIImatics Animations
  [ "${SPLASH}" ] && FULLSCREEN=1

  # Set the command to use based on command line switches (-S, -T)
  MPCOMM="${MPCPLUS}"
  if [ "${SPLASH}" ]
  then
    if [ "${TMUX_SPLASH}" ]
    then
      MPCOMM="${MPPSPLASH_TMUX}"
    else
      MPCOMM="${MPPSPLASH}"
    fi
  else
    [ "${TMUX_MPC}" ] && {
      if [ "${USE_MPCPLUS}" ]
      then
        MPCOMM="${MPCPLUS_TMUX}"
      else
        MPCOMM="${MPCPLUS_TMUX} -c '${MPCPLUS}'"
      fi
    }
  fi

  # Begin MPD client startup section
  if [ "${CONSOLE_MODE}" ] || [ "${CURRENT}" ]
  then
    ${MPCOMM}
  else
    if [ "${FULLSCREEN}" ]
    then
      if [ "${KITTY}" ]
      then
        kitty --title="${MTITLE}" \
              --start-as fullscreen \
              --override font_size=18 \
              --override background_opacity=0.7 \
              --override tab_bar_min_tabs=2 \
              ${MPCOMM} 2> /dev/null &
      else
        if [ "${TILIX}" ]
        then
          tilix --title="${MTITLE}" \
                --full-screen \
                --window-style=borderless \
                --profile=MusicPlayer \
                --command="${MPCOMM}" 2> /dev/null &
        else
          if [ "${GNOME}" ]
          then
            gnome-terminal --title="${MTITLE}" \
                  --profile=MusicPlayer \
                  --hide-menubar \
                  --full-screen \
                  -- ${MPCOMM} &
          else
            if [ "${SIMPLE}" ]
            then
              st -t "${MTITLE}" \
                 -g "800x600" \
                 -f "Monospace:size=24" \
                 ${MPCOMM} 2> /dev/null &
            else
              if [ "${RETRO}" ]
              then
                cool-retro-term --fullscreen -e ${MPCOMM} > /dev/null 2>&1 &
              else
                ${MPCOMM}
              fi
            fi
          fi
        fi
      fi
    else
      if [ "${KITTY}" ]
      then
        kitty --title="${MTITLE}" \
              --start-as normal \
              --override font_size=18 \
              --override initial_window_width=120c \
              --override initial_window_height=28c \
              --override tab_bar_min_tabs=2 \
              ${MPCOMM} 2> /dev/null &
        [ "${USE_EWMH}" ] && {
          sleep 1
          mpc_win=`wmctrl -l -G -x | grep kitty.kitty | \
            grep -v "${VTITLE}" | grep "${MTITLE}"`
          [ "${mpc_win}" ] || {
            mpc_win=`wmctrl -l -G -x | grep kitty.kitty | \
              grep -v "${VISUALIZER}" | grep "${MPCOMM}"`
          }
          [ "${mpc_win}" ] && center_window "${mpc_win}" "${vhit}"
        }
      else
        if [ "${TILIX}" ]
        then
          tilix --title="${MTITLE}" \
                --window-style=borderless \
                --geometry=90x20+150+25 \
                --profile=MusicPlayer \
                --command="${MPCOMM}" 2> /dev/null &
          [ "${USE_EWMH}" ] && {
            sleep 1
            til_win=`wmctrl -l -G -x | grep tilix.Tilix | \
              grep -v "${VTITLE}" | grep "${MTITLE}"`
            [ "${til_win}" ] || {
              til_win=`wmctrl -l -G -x | grep tilix.Tilix | \
                grep -v "${VISUALIZER}" | grep "${MPCOMM}"`
            }
            [ "${til_win}" ] && center_window "${til_win}" "${vhit}"
          }
        else
          if [ "${GNOME}" ]
          then
            gnome-terminal --title="${MTITLE}" \
                  --profile=MusicPlayer \
                  --hide-menubar \
                  --geometry=90x20+150+25 \
                  -- ${MPCOMM} &
            [ "${USE_EWMH}" ] && {
              sleep 1
              gno_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                grep -v "${VTITLE}" | grep "${MTITLE}"`
              [ "${gno_win}" ] || {
                gno_win=`wmctrl -l -G -x | grep gnome-terminal-server | \
                  grep -v "${VISUALIZER}" | grep "${MPCOMM}"`
              }
              [ "${gno_win}" ] && center_window "${gno_win}" "${vhit}"
            }
          else
            if [ "${SIMPLE}" ]
            then
              st -t "${MTITLE}" \
                 -g "100x26+50+25" \
                 -f "Monospace:size=24" \
                 ${MPCOMM} 2> /dev/null &
              [ "${USE_EWMH}" ] && {
                sleep 1
                stl_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                  grep -v "${VTITLE}" | grep "${MTITLE}"`
                [ "${stl_win}" ] || {
                  stl_win=`wmctrl -l -G -x | grep st-256color.st-256color | \
                    grep -v "${VISUALIZER}" | grep "${MPCOMM}"`
                }
                [ "${stl_win}" ] && center_window "${stl_win}" "${vhit}"
              }
            else
              if [ "${RETRO}" ]
              then
                cool-retro-term -e ${MPCOMM} > /dev/null 2>&1 &
              else
                ${MPCOMM} &
                # TODO: handle other graphical mpd clients
                [ "${MPCOMM}" == "cantata" ] && [ "${USE_EWMH}" ] && {
                  sleep 1
                  can_win=`wmctrl -l -G -x | grep cantata.cantata | \
                    grep "Cantata"`
                  [ "${can_win}" ] || {
                    can_win=`wmctrl -l -G -x | grep cantata.cantata | \
                      grep -i "cantata"`
                  }
                  [ "${can_win}" ] && center_window "${can_win}" "top"
                }
              fi
            fi
          fi
        fi
      fi
    fi
  fi
  # End MPD client startup section
}

select_font() {
  # Array with font names
  fonts=("Bolger" "Lean" "sblood" "Slant" "Shadow" "Speed" "Varsity" "Small" "Small Script" "Small Shadow" "Small Slant")
  smallfonts=("Small" "Small Script" "Small Shadow" "Small Slant")

  # Seed random generator
  RANDOM=$$$(date +%s)

  if [ "$1" == "small" ]
  then
    USE_FONT=${smallfonts[ $RANDOM % ${#smallfonts[@]} ]}
  else
    USE_FONT=${fonts[ $RANDOM % ${#fonts[@]} ]}
  fi
  [ "${USE_FONT}" == "Lean" ] && {
    [ "${FULLSCREEN}" ] || {
      while [ "${USE_FONT}" == "Lean" ]
      do
        USE_FONT=${fonts[ $RANDOM % ${#fonts[@]} ]}
      done
    }
  }
  [ -r "${FIG_FONTS}/${USE_FONT}.flf" ] || {
    if [ -r "${FIG_FONTS}/Standard.flf" ]
    then
      USE_FONT="Standard"
    else
      USE_FONT="standard"
    fi
  }
}

do_service_action() {
  local service="$1"
  local action="$2"
  case ${action} in
    alsaconf)
      sudo alsa_conf -e -m
      ;;
    start)
      systemctl --user is-active ${service} >/dev/null 2>&1 || {
        systemctl --user ${action} ${service}
      }
      [ "${service}" == "mopidy.service" ] && {
        # Perform a local scan of the music library
        have_mopidy=`type -p mopidy`
        [ "${have_mopidy}" ] && mopidy local scan > /dev/null 2>&1 &
        # Reconfigure mpcplus/mppcava with Mopidy visualizer data source
        [ -x ${SCRIPTS}/viz_data_src.sh ] && ${SCRIPTS}/viz_data_src.sh mopidy
      }
      [ "${service}" == "mpd.service" ] && {
        # Update the MPD library database
        [ "${have_mpc}" ] && mpc update --quiet > /dev/null 2>&1 &
        # Reconfigure mpcplus/mppcava with MPD visualizer data source
        [ -x ${SCRIPTS}/viz_data_src.sh ] && ${SCRIPTS}/viz_data_src.sh mpd
      }
      ;;
    stop)
      systemctl --user is-active ${service} >/dev/null 2>&1 && {
        systemctl --user ${action} ${service}
      }
      [ "${service}" == "mpd.service" ] && {
        systemctl --user is-active mpd.socket >/dev/null 2>&1 && {
          systemctl --user ${action} mpd.socket
        }
      }
      [ "${service}" == "pulseaudio.service" ] && {
        systemctl --user is-active pulseaudio.socket >/dev/null 2>&1 && {
          systemctl --user ${action} pulseaudio.socket
        }
      }
      ;;
    disable)
      systemctl --user is-enabled ${service} >/dev/null 2>&1 && {
        systemctl --user ${action} ${service}
      }
      [ "${service}" == "mpd.service" ] && {
        systemctl --user is-enabled mpd.socket >/dev/null 2>&1 && {
          systemctl --user ${action} mpd.socket
        }
        sudo systemctl --user --global disable mpd.socket
      }
      [ "${service}" == "pulseaudio.service" ] && {
        systemctl --user is-enabled pulseaudio.socket >/dev/null 2>&1 && {
          systemctl --user ${action} pulseaudio.socket
        }
        sudo systemctl --user --global disable pulseaudio.socket
      }
      ;;
    enable)
      systemctl --user is-enabled ${service} >/dev/null 2>&1 || {
        systemctl --user ${action} ${service}
      }
      [ "${service}" == "mopidy.service" ] && {
        # Perform a local scan of the music library
        have_mopidy=`type -p mopidy`
        [ "${have_mopidy}" ] && mopidy local scan > /dev/null 2>&1 &
        # Reconfigure mpcplus/mppcava with Mopidy visualizer data source
        [ -x ${SCRIPTS}/viz_data_src.sh ] && ${SCRIPTS}/viz_data_src.sh mopidy
      }
      [ "${service}" == "mpd.service" ] && {
        # Update the MPD library database
        [ "${have_mpc}" ] && mpc update --quiet > /dev/null 2>&1 &
        # Reconfigure mpcplus/mppcava with MPD visualizer data source
        [ -x ${SCRIPTS}/viz_data_src.sh ] && ${SCRIPTS}/viz_data_src.sh mpd
      }
      ;;
    restart)
      systemctl --user ${action} ${service}
      [ "${service}" == "mopidy.service" ] && {
        # Perform a local scan of the music library
        have_mopidy=`type -p mopidy`
        [ "${have_mopidy}" ] && mopidy local scan > /dev/null 2>&1 &
      }
      [ "${service}" == "mpd.service" ] && {
        # Update the MPD library database
        [ "${have_mpc}" ] && mpc update --quiet > /dev/null 2>&1 &
      }
      ;;
    status)
      systemctl --user --full ${action} ${service}
      ;;
    *)
      echo "Unrecognized service action: ${action}"
      ;;
  esac
}

mpp_service() {
  ALL_SERVICES="navidrome mopidy mpdstats webplugin yams mpd pulseaudio"
  SERVICE_ACTION=$1
  if [ "$2" == "ALL" ]
  then
    for srvc in ${ALL_SERVICES}
    do
      SERVICE="${srvc}.service"
      do_service_action "${SERVICE}" "${SERVICE_ACTION}"
    done
  else
    SERVICE=${2}.service
    do_service_action "${SERVICE}" "${SERVICE_ACTION}"
  fi
}

show_menu_title() {
  columns="$(tput cols)"
  menu_title="$1"
  if [ "${have_lolcat}" ]
  then
    printf "%*s\n" $(( (${#menu_title} + columns) / 2)) "${menu_title}" | lolcat
  else
    printf "%*s\n" $(( (${#menu_title} + columns) / 2)) "${menu_title}"
  fi
}

show_figlet() {
  if [ "${have_lolcat}" ]
  then
    if [ "${USE_FONT}" == "Lean" ]
    then
      figlet -c -d ${FIG_FONTS} -f "${USE_FONT}" -k -t ${FIG_TEXT} | tr ' _/' ' ()' | lolcat
    else
      figlet -c -d ${FIG_FONTS} -f "${USE_FONT}" -k -t ${FIG_TEXT} | lolcat
    fi
  else
    if [ "${USE_FONT}" == "Lean" ]
    then
      figlet -c -d ${FIG_FONTS} -f "${USE_FONT}" -k -t ${FIG_TEXT} | tr ' _/' ' ()'
    else
      figlet -c -d ${FIG_FONTS} -f "${USE_FONT}" -k -t ${FIG_TEXT}
    fi
  fi
}

show_help_menu() {
  MTITLE="MusicPlayerPlus Help"
  while true
  do
    FIG_TEXT="Help Menu"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} choice (numeric or text): ${NORM}"
    options=()
    options+=("MusicPlayerPlus README")
    options+=("MusicPlayerPlus Man Page")
    options+=("MusicPlayerPlus Animation Man Page")
    options+=("ASCIInema Man Page")
    options+=("Julia Set Animation Man Page")
    options+=("MusicPlayer Animation Man Page")
    options+=("ASCII Splash Man Page")
    options+=("ASCII Splash Tmux Man Page")
    options+=("Alsa Conf Man Page")
    options+=("Beet Man Page")
    options+=("Create Playlist Man Page")
    options+=("Bandcamp Download Man Page")
    options+=("Soundcloud Download Man Page")
    options+=("Fzmp Man Page")
    options+=("Listyt Man Page")
    options+=("Mpcplus-tmux Man Page")
    options+=("Mpcplus Man Page")
    options+=("Mpcpluskeys Man Page")
    options+=("Mpd-configure Man Page")
    options+=("Mpd-monitor Man Page")
    options+=("Mppcava Man Page")
    options+=("Mppinit Man Page")
    options+=("Mppjulia Man Page")
    options+=("Mpplus Man Page")
    options+=("Mppplasma Man Page")
    options+=("Mpprocks Man Page")
    options+=("Mppsplash-tmux Man Page")
    options+=("Mppsplash Man Page")
    options+=("Beetsconfig Man Page")
    options+=("Tmux Multiplexer Man Page")
    [ "${have_lynx}" ] && options+=("Lynx Web Browser Man Page")
    [ "${have_w3m}" ] && options+=("W3m Web Browser Man Page")
    [ "${have_retro}" ] && options+=("Retro Terminal Man Page")
    [ "${have_gnome}" ] && options+=("Gnome Terminal Man Page")
    [ "${have_kitty}" ] && options+=("Kitty Terminal Man Page")
    [ "${have_simple}" ] && options+=("Simple Terminal Man Page")
    [ "${have_tilix}" ] && options+=("Tilix Terminal Man Page")
    options+=("Done / Back" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
        "Done"*,*|*,"Done"*|"done"*,*|*,"done"*|"Back"*,*|*,"Back"*|"back"*,*|*,"back"*)
          clear
          printf "\n"
          break 2
          ;;
        "MusicPlayerPlus README",*|*,"MusicPlayerPlus README")
          if [ "${have_w3m}" ]
          then
            w3m ${DOC_DIR}/README.html
          else
            if [ "${have_lynx}" ]
            then
              lynx ${DOC_DIR}/README.html
            else
              less ${DOC_DIR}/README.md
            fi
          fi
          break
          ;;
        "MusicPlayerPlus Man"*,*|*,"MusicPlayerPlus Man"*)
          man mpplus
          break
          ;;
        "MusicPlayerPlus Animation"*,*|*,"MusicPlayerPlus Animation"*)
          man mpprocks
          break
          ;;
        "ASCIInema"*,*|*,"ASCIInema"*)
          man asciinema
          break
          ;;
        "ASCII Splash Tmux"*,*|*,"ASCII Splash Tmux"*)
          man mppsplash-tmux
          break
          ;;
        "ASCII Splash"*,*|*,"ASCII Splash"*)
          man mppsplash
          break
          ;;
        "Alsa Conf"*,*|*,"Alsa Conf"*)
          man alsa_conf
          break
          ;;
        "Beet"*,*|*,"Beet"*)
          man beet
          break
          ;;
        "Beetsconfig"*,*|*,"Beetsconfig"*)
          man beetsconfig
          break
          ;;
        "Create Playlist"*,*|*,"Create Playlist"*)
          man create_playlist
          break
          ;;
        "Bandcamp"*,*|*,"Bandcamp"*)
          man bandcamp-dl
          break
          ;;
        "Soundcloud"*,*|*,"Soundcloud"*)
          man scdl
          break
          ;;
        "Fzmp"*,*|*,"Fzmp"*)
          man fzmp
          break
          ;;
        "Listyt"*,*|*,"Listyt"*)
          man listyt
          break
          ;;
        "Mpcplus-tmux"*,*|*,"Mpcplus-tmux"*)
          man mpcplus-tmux
          break
          ;;
        "Mpcplus"*,*|*,"Mpcplus"*)
          man mpcplus
          break
          ;;
        "Mpcpluskeys"*,*|*,"Mpcpluskeys"*)
          man mpcpluskeys
          break
          ;;
        "Mpd-configure"*,*|*,"Mpd-configure"*)
          man mpd-configure
          break
          ;;
        "Mpd-monitor"*,*|*,"Mpd-monitor"*)
          man mpd-monitor
          break
          ;;
        "Mppcava"*,*|*,"Mppcava"*)
          man mppcava
          break
          ;;
        "Mppinit"*,*|*,"Mppinit"*)
          man mppinit
          break
          ;;
        "Mppjulia"*,*|*,"Mppjulia"*)
          man mppjulia
          break
          ;;
        "Mppplasma"*,*|*,"Mppplasma"*)
          man mppplasma
          break
          ;;
        "Mpprocks"*,*|*,"Mpprocks"*)
          man mpprocks
          break
          ;;
        "Mpplus"*,*|*,"Mpplus"*)
          man mpplus
          break
          ;;
        "Mppsplash-tmux"*,*|*,"Mppsplash-tmux"*)
          man mppsplash-tmux
          break
          ;;
        "Mppsplash"*,*|*,"Mppsplash"*)
          man mppsplash
          break
          ;;
        "Tmux"*,*|*,"Tmux"*)
          man tmux
          break
          ;;
        "Lynx"*,*|*,"Lynx"*)
          man lynx
          break
          ;;
        "W3m"*,*|*,"W3m"*)
          man w3m
          break
          ;;
        "Retro"*,*|*,"Retro"*)
          man cool-retro-term
          break
          ;;
        "Gnome"*,*|*,"Gnome"*)
          man gnome-terminal
          break
          ;;
        "Kitty"*,*|*,"Kitty"*)
          man kitty
          break
          ;;
        "Simple"*,*|*,"Simple"*)
          man st
          break
          ;;
        "Tilix"*,*|*,"Tilix"*)
          man tilix
          break
          ;;
        "Quit",*|*,"Quit"|"quit",*|*,"quit")
          printf "\nExiting MusicPlayerPlus\n"
          exit 0
          ;;
        *,*|*,*)
          printf "\nCould not match '${REPLY}' with a menu entry."
          printf "\nPlease try again with an exact match.\n"
          ;;
      esac
      REPLY=
    done
  done
  clear
  printf "\n"
}

show_downloads_menu() {
  while true
  do
    FIG_TEXT="Downloads"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=("Download Album Cover Art" "Download Bandcamp Songs")
    options+=("Download Soundcloud Songs" "Download YouTube Songs")
    options+=("Download Audio in URL")
    options+=("List YouTube Playlists")
    options+=("List YouTube Uploads")
    options+=("List YouTube URL")
    options+=("Main menu" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              break
              ;;
          "Main menu",*|*,"Main menu"|"Back",*|*,"Back"|"back",*|*,"back")
              clear
              printf "\n"
              init_vars
              show_main_menu
              break 2
              ;;
          "Download Album"*,*|*,"Download Album"*)
              DOWNLOAD_ART=1
              break
              ;;
          "Download Bandcamp"*,*|*,"Download Bandcamp"*)
              DOWNLOAD_BANDCAMP=1
              break
              ;;
          "Download Soundcloud"*,*|*,"Download Soundcloud"*)
              DOWNLOAD_SOUNDCLOUD=1
              break
              ;;
          "Download YouTube"*,*|*,"Download YouTube"*)
              DOWNLOAD_YOUTUBE=1
              break
              ;;
          "Download Audio"*,*|*,"Download Audio"*)
              DOWNLOAD_YOUTUBE=1
              break
              ;;
          "List YouTube Playlists"*,*|*,"List YouTube Playlists"*)
              LIST_YT_PLAYLISTS=1
              break
              ;;
          "List YouTube Uploads"*,*|*,"List YouTube Uploads"*)
              LIST_YT_UPLOADS=1
              break
              ;;
          "List YouTube URL"*,*|*,"List YouTube URL"*)
              LIST_YT_URL=1
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
      REPLY=
    done
    [ "${skip_it_so}" ] || {
      make_it_so
      init_vars
    }
  done
}

show_system_status() {
  systemctl --user is-active mpd.service >/dev/null 2>&1 && \
    m_active="active" || m_active="inactive"
  systemctl --user is-enabled mpd.service >/dev/null 2>&1 && \
    m_enabled="enabled" || m_enabled="disabled"
  systemctl --user is-active pulseaudio.service >/dev/null 2>&1 && \
    p_active="active" || p_active="inactive"
  systemctl --user is-enabled pulseaudio.service >/dev/null 2>&1 && \
    p_enabled="enabled" || p_enabled="disabled"
  systemctl --user is-active mpdstats.service >/dev/null 2>&1 && \
    s_active="active" || s_active="inactive"
  systemctl --user is-enabled mpdstats.service >/dev/null 2>&1 && \
    s_enabled="enabled" || s_enabled="disabled"
  systemctl --user is-active webplugin.service >/dev/null 2>&1 && \
    w_active="active" || w_active="inactive"
  systemctl --user is-enabled webplugin.service >/dev/null 2>&1 && \
    w_enabled="enabled" || w_enabled="disabled"
  systemctl --user is-active yams.service >/dev/null 2>&1 && \
    y_active="active" || y_active="inactive"
  systemctl --user is-enabled yams.service >/dev/null 2>&1 && \
    y_enabled="enabled" || y_enabled="disabled"
  systemctl --user is-active mopidy.service >/dev/null 2>&1 && \
    z_active="active" || z_active="inactive"
  systemctl --user is-enabled mopidy.service >/dev/null 2>&1 && \
    z_enabled="enabled" || z_enabled="disabled"
  systemctl --user is-active navidrome.service >/dev/null 2>&1 && \
    n_active="active" || n_active="inactive"
  systemctl --user is-enabled navidrome.service >/dev/null 2>&1 && \
    n_enabled="enabled" || n_enabled="disabled"
  if [ "${have_navi}" ]
  then
    n_inst="installed"
  else
    n_inst="not installed"
  fi
  if [ "${have_mopidy}" ]
  then
    z_inst="installed"
  else
    z_inst="not installed"
  fi
  [ "${m_enabled}" == "enabled" ] || [ "${m_active}" == "active" ] && {
    printf "\nMusic Player Daemon service is ${m_enabled} and ${m_active}"
  }
  [ "${p_enabled}" == "enabled" ] || [ "${p_active}" == "active" ] && {
    printf "\nPulseAudio service is ${p_enabled} and ${p_active}"
  }
  [ "${s_enabled}" == "enabled" ] || [ "${s_active}" == "active" ] && {
    printf "\nBeets MPD Stats service is ${s_enabled} and ${s_active}"
  }
  [ "${w_enabled}" == "enabled" ] || [ "${w_active}" == "active" ] && {
    printf "\nBeets Web service is ${w_enabled} and ${w_active}"
  }
  [ "${y_enabled}" == "enabled" ] || [ "${y_active}" == "active" ] && {
    printf "\nLast.fm Scrobbler service is ${y_enabled} and ${y_active}"
  }
  [ "${z_enabled}" == "enabled" ] || [ "${z_active}" == "active" ] && {
    printf "\nMopidy Server is ${z_inst}, ${z_enabled} and ${z_active}"
  }
  [ "${n_enabled}" == "enabled" ] || [ "${n_active}" == "active" ] && {
    printf "\nNavidrome Server is ${n_inst}, ${n_enabled} and ${n_active}"
  }
  printf "\n"
}

show_logs_menu() {
  have_alsa=`type -p alsa-info`
  while true
  do
    show_system_status
    FIG_TEXT="Service Logs Menu"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=()
    [ "${have_alsa}" ] && options+=("ALSA Sound System Info")
    [ "${s_active}" == "active" ] || [ "${s_enabled}" == "enabled" ] && {
      options+=("View Beets MPD Stats Log")
    }
    [ "${w_active}" == "active" ] || [ "${w_enabled}" == "enabled" ] && {
      options+=("View Beets Web Service Log")
    }
    [ "${m_active}" == "active" ] || [ "${m_enabled}" == "enabled" ] && {
      options+=("View Music Player Daemon Log")
    }
    [ "${z_active}" == "active" ] || [ "${z_enabled}" == "enabled" ] && {
      options+=("View Mopidy Server Log")
    }
    [ "${n_active}" == "active" ] || [ "${n_enabled}" == "enabled" ] && {
      options+=("View Navidrome Server Log")
    }
    [ "${p_active}" == "active" ] || [ "${p_enabled}" == "enabled" ] && {
      options+=("View PulseAudio Server Log")
    }
    [ "${y_active}" == "active" ] || [ "${y_enabled}" == "enabled" ] && {
      options+=("View Last.FM Scrobbler Log")
    }
    options+=("Manage Music Services")
    options+=("Main menu" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              break
              ;;
          "Main menu",*|*,"Main menu"|"Back",*|*,"Back"|"back",*|*,"back")
              clear
              printf "\n"
              init_vars
              show_main_menu
              break 2
              ;;
          "ALSA Sound System Info",*|*,"ALSA Sound System Info")
              alsa-info --stdout | less
              break
              ;;
          "View Beets MPD Stats Log",*|*,"View Beets MPD Stats Log")
              journalctl --user-unit=mpdstats.service --since yesterday
              break
              ;;
          "View Beets Web Service Log",*|*,"View Beets Web Service Log")
              journalctl --user-unit=webplugin.service --since yesterday
              break
              ;;
          "View Music Player Daemon Log",*|*,"View Music Player Daemon Log")
              journalctl --user-unit=mpd.service --since yesterday
              break
              ;;
          "View Mopidy Server Log",*|*,"View Mopidy Server Log")
              journalctl --user-unit=mopidy.service --since yesterday
              break
              ;;
          "View Navidrome Server Log",*|*,"View Navidrome Server Log")
              journalctl --user-unit=navidrome.service --since yesterday
              break
              ;;
          "View PulseAudio Server Log",*|*,"View PulseAudio Server Log")
              journalctl --user-unit=pulseaudio.service --since yesterday
              break
              ;;
          "View Last.FM Scrobbler Log",*|*,"View Last.FM Scrobbler Log")
              journalctl --user-unit=yams.service --since yesterday
              break
              ;;
          "Manage Music Services"*,*|*,"Manage Music Services"*)
              clear
              printf "\n"
              show_services_menu
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
      REPLY=
    done
  done
  init_vars
}

show_services_menu() {
  while true
  do
    show_system_status
    FIG_TEXT="Services Menu"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=("Configure ALSA Sound System")
    [ "${have_mopidy}" ] || options+=("Install Mopidy Server")
    [ "${have_navi}" ] || options+=("Install Navidrome Server")
    if [ "${w_enabled}" == "enabled" ]
    then
      options+=("Disable Beets Web Service")
    else
      options+=("Enable Beets Web Service")
    fi
    if [ "${s_enabled}" == "enabled" ]
    then
      options+=("Disable Beets MPD Stats")
    else
      options+=("Enable Beets MPD Stats")
    fi
    if [ "${m_enabled}" == "enabled" ]
    then
      options+=("Disable Music Player Daemon")
    else
      options+=("Enable Music Player Daemon")
    fi
    [ "${have_mopidy}" ] && {
      if [ "${z_enabled}" == "enabled" ]
      then
        options+=("Disable Mopidy Server")
      else
        options+=("Enable Mopidy Server")
      fi
    }
    [ "${have_navi}" ] && {
      if [ "${n_enabled}" == "enabled" ]
      then
        options+=("Disable Navidrome Server")
      else
        options+=("Enable Navidrome Server")
      fi
    }
    if [ "${p_enabled}" == "enabled" ]
    then
      options+=("Disable PulseAudio")
    else
      options+=("Enable PulseAudio")
    fi
    if [ "${y_enabled}" == "enabled" ]
    then
      options+=("Disable Last.FM Scrobbler")
    else
      options+=("Enable Last.FM Scrobbler")
    fi
    if [ "${s_active}" == "active" ]
    then
      options+=("Stop Beets MPD Stats")
      options+=("Restart Beets MPD Stats")
    else
      options+=("Start Beets MPD Stats")
    fi
    if [ "${w_active}" == "active" ]
    then
      options+=("Stop Beets Web Service")
      options+=("Restart Beets Web Service")
    else
      options+=("Start Beets Web Service")
    fi
    if [ "${m_active}" == "active" ]
    then
      options+=("Stop Music Player Daemon")
      options+=("Restart Music Player Daemon")
    else
      options+=("Start Music Player Daemon")
    fi
    [ "${have_mopidy}" ] && {
      if [ "${z_active}" == "active" ]
      then
        options+=("Stop Mopidy Server")
        options+=("Restart Mopidy Server")
      else
        options+=("Start Mopidy Server")
      fi
    }
    [ "${have_navi}" ] && {
      if [ "${n_active}" == "active" ]
      then
        options+=("Stop Navidrome Server")
        options+=("Restart Navidrome Server")
      else
        options+=("Start Navidrome Server")
      fi
    }
    if [ "${p_active}" == "active" ]
    then
      options+=("Stop PulseAudio")
      options+=("Restart PulseAudio")
    else
      options+=("Start PulseAudio")
    fi
    if [ "${y_active}" == "active" ]
    then
      options+=("Stop Last.FM Scrobbler")
      options+=("Restart Last.FM Scrobbler")
    else
      options+=("Start Last.FM Scrobbler")
    fi
    [ "${m_enabled}" == "enabled" ] || [ "${m_active}" == "active" ] && {
      options+=("Status of Music Player Daemon")
    }
    [ "${s_enabled}" == "enabled" ] || [ "${s_active}" == "active" ] && {
      options+=("Status of Beets MPD Stats")
    }
    [ "${w_enabled}" == "enabled" ] || [ "${w_active}" == "active" ] && {
      options+=("Status of Beets Web Service")
    }
    [ "${z_enabled}" == "enabled" ] || [ "${z_active}" == "active" ] && {
      [ "${have_mopidy}" ] && options+=("Status of Mopidy Server")
    }
    [ "${n_enabled}" == "enabled" ] || [ "${n_active}" == "active" ] && {
      [ "${have_navi}" ] && options+=("Status of Navidrome Server")
    }
    [ "${p_enabled}" == "enabled" ] || [ "${p_active}" == "active" ] && {
      options+=("Status of PulseAudio")
    }
    [ "${y_enabled}" == "enabled" ] || [ "${y_active}" == "active" ] && {
      options+=("Status of Last.FM Scrobbler")
    }
    options+=("Stop All Active Services")
    [ "${z_active}" == "active" ] && [ "${have_mopidy}" ] && {
      options+=("Update/scan Mopidy music library")
    }
    [ "${m_active}" == "active" ] && [ "${have_mpc}" ] && {
      options+=("Update/scan MPD music library")
    }
    options+=("View Music Service Logs")
    options+=("Main menu" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              break
              ;;
          "Main menu",*|*,"Main menu"|"Back",*|*,"Back"|"back",*|*,"back")
              clear
              printf "\n"
              init_vars
              show_main_menu
              break 2
              ;;
          "Configure ALSA Sound System",*|*,"Configure ALSA Sound System")
              mpp_service alsaconf
              break
              ;;
          "Install Mopidy Server",*|*,"Install Mopidy Server")
              mppinit mopidy
              have_mopidy=`type -p mopidy`
              break
              ;;
          "Enable Mopidy Server",*|*,"Enable Mopidy Server")
              mpp_service disable mpdstats
              mpp_service stop mpdstats
              mpp_service disable yams
              mpp_service stop yams
              mpp_service disable mpd
              mpp_service stop mpd
              mpp_service enable mopidy
              break
              ;;
          "Disable Mopidy Server",*|*,"Disable Mopidy Server")
              mpp_service disable mopidy
              break
              ;;
          "Start Mopidy Server",*|*,"Start Mopidy Server")
              mpp_service disable mpdstats
              mpp_service stop mpdstats
              mpp_service disable yams
              mpp_service stop yams
              mpp_service disable mpd
              mpp_service stop mpd
              mpp_service start mopidy
              break
              ;;
          "Stop Mopidy Server",*|*,"Stop Mopidy Server")
              mpp_service stop mopidy
              break
              ;;
          "Restart Mopidy Server",*|*,"Restart Mopidy Server")
              mpp_service disable mpdstats
              mpp_service stop mpdstats
              mpp_service disable yams
              mpp_service stop yams
              mpp_service disable mpd
              mpp_service stop mpd
              mpp_service restart mopidy
              break
              ;;
          "Status of Mopidy Server",*|*,"Status of Mopidy Server")
              mpp_service status mopidy
              break
              ;;
          "Install Navidrome Server",*|*,"Install Navidrome Server")
              mppinit navidrome
              if [ -x /opt/navidrome/navidrome ]
              then
                have_navi=1
              else
                have_navi=
              fi
              break
              ;;
          "Enable Navidrome Server",*|*,"Enable Navidrome Server")
              mpp_service enable navidrome
              break
              ;;
          "Disable Navidrome Server",*|*,"Disable Navidrome Server")
              mpp_service disable navidrome
              break
              ;;
          "Start Navidrome Server",*|*,"Start Navidrome Server")
              mpp_service start navidrome
              break
              ;;
          "Stop Navidrome Server",*|*,"Stop Navidrome Server")
              mpp_service stop navidrome
              break
              ;;
          "Restart Navidrome Server",*|*,"Restart Navidrome Server")
              mpp_service restart navidrome
              break
              ;;
          "Status of Navidrome Server",*|*,"Status of Navidrome Server")
              mpp_service status navidrome
              break
              ;;
          "Enable Music Player Daemon",*|*,"Enable Music Player Daemon")
              [ "${have_mopidy}" ] && {
                mpp_service disable mopidy
                mpp_service stop mopidy
              }
              mpp_service enable mpd
              break
              ;;
          "Disable Music Player Daemon",*|*,"Disable Music Player Daemon")
              mpp_service disable mpd
              break
              ;;
          "Start Music Player Daemon",*|*,"Start Music Player Daemon")
              [ "${have_mopidy}" ] && {
                mpp_service disable mopidy
                mpp_service stop mopidy
              }
              mpp_service start mpd
              break
              ;;
          "Stop Music Player Daemon",*|*,"Stop Music Player Daemon")
              mpp_service stop mpd
              break
              ;;
          "Restart Music Player Daemon",*|*,"Restart Music Player Daemon")
              [ "${have_mopidy}" ] && {
                mpp_service disable mopidy
                mpp_service stop mopidy
              }
              mpp_service restart mpd
              break
              ;;
          "Status of Music Player Daemon",*|*,"Status of Music Player Daemon")
              if [ "${have_mpc}" ]
              then
                { mpc stats && \
                  mpp_service status mpd; } | less
              else
                mpp_service status mpd
              fi
              break
              ;;
          "Enable PulseAudio",*|*,"Enable PulseAudio")
              mpp_service enable pulseaudio
              break
              ;;
          "Disable PulseAudio",*|*,"Disable PulseAudio")
              mpp_service disable pulseaudio
              break
              ;;
          "Start PulseAudio",*|*,"Start PulseAudio")
              mpp_service start pulseaudio
              break
              ;;
          "Stop PulseAudio",*|*,"Stop PulseAudio")
              mpp_service stop pulseaudio
              break
              ;;
          "Restart PulseAudio",*|*,"Restart PulseAudio")
              mpp_service restart pulseaudio
              break
              ;;
          "Status of PulseAudio",*|*,"Status of PulseAudio")
              mpp_service status pulseaudio
              break
              ;;
          "Enable Beets MPD Stats",*|*,"Enable Beets MPD Stats")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Stats not compatible with Mopidy"
                  echo "Enable MPD to use MPD Stats"
                  break
                }
              }
              mpp_service enable mpdstats
              break
              ;;
          "Disable Beets MPD Stats",*|*,"Disable Beets MPD Stats")
              mpp_service disable mpdstats
              break
              ;;
          "Start Beets MPD Stats",*|*,"Start Beets MPD Stats")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Stats not compatible with Mopidy"
                  echo "Enable MPD to use MPD Stats"
                  break
                }
              }
              mpp_service start mpdstats
              break
              ;;
          "Stop Beets MPD Stats",*|*,"Stop Beets MPD Stats")
              mpp_service stop mpdstats
              break
              ;;
          "Restart Beets MPD Stats",*|*,"Restart Beets MPD Stats")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Stats not compatible with Mopidy"
                  echo "Enable MPD to use MPD Stats"
                  break
                }
              }
              mpp_service restart mpdstats
              break
              ;;
          "Status of Beets MPD Stats",*|*,"Status of Beets MPD Stats")
              mpp_service status mpdstats
              break
              ;;
          "Enable Beets Web Service",*|*,"Enable Beets Web Service")
              mpp_service enable webplugin
              break
              ;;
          "Disable Beets Web Service",*|*,"Disable Beets Web Service")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "Mopidy Beets extension requires the Beets Web Service."
                  echo "Disable the Mopidy Beets extension before disabling"
                  echo "the Beets Web Service."
                  break
                }
              }
              mpp_service disable webplugin
              break
              ;;
          "Start Beets Web Service",*|*,"Start Beets Web Service")
              mpp_service start webplugin
              break
              ;;
          "Stop Beets Web Service",*|*,"Stop Beets Web Service")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "Mopidy Beets extension requires the Beets Web Service."
                  echo "Disable the Mopidy Beets extension before stopping"
                  echo "the Beets Web Service."
                  break
                }
              }
              mpp_service stop webplugin
              break
              ;;
          "Restart Beets Web Service",*|*,"Restart Beets Web Service")
              mpp_service restart webplugin
              break
              ;;
          "Status of Beets Web Service",*|*,"Status of Beets Web Service")
              mpp_service status webplugin
              break
              ;;
          "Enable Last.FM Scrobbler",*|*,"Enable Last.FM Scrobbler")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Scrobbler not compatible with Mopidy"
                  echo "Enable MPD to use MPD Scrobbler"
                  break
                }
              }
              mpp_service enable yams
              break
              ;;
          "Disable Last.FM Scrobbler",*|*,"Disable Last.FM Scrobbler")
              mpp_service disable yams
              break
              ;;
          "Start Last.FM Scrobbler",*|*,"Start Last.FM Scrobbler")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Scrobbler not compatible with Mopidy"
                  echo "Enable MPD to use MPD Scrobbler"
                  break
                }
              }
              mpp_service start yams
              break
              ;;
          "Stop Last.FM Scrobbler",*|*,"Stop Last.FM Scrobbler")
              mpp_service stop yams
              break
              ;;
          "Restart Last.FM Scrobbler",*|*,"Restart Last.FM Scrobbler")
              [ "${have_mopidy}" ] && {
                [ "${z_active}" == "active" ] || \
                [ "${z_enabled}" == "enabled" ] && {
                  echo "MPD Scrobbler not compatible with Mopidy"
                  echo "Enable MPD to use MPD Scrobbler"
                  break
                }
              }
              mpp_service restart yams
              break
              ;;
          "Status of Last.FM Scrobbler",*|*,"Status of Last.FM Scrobbler")
              mpp_service status yams
              break
              ;;
          "Stop All"*,*|*,"Stop All"*)
              mpp_service stop ALL
              break
              ;;
          "Update/scan Mopidy"*,*|*,"Update/scan Mopidy"*)
              mopidy local scan > /dev/null 2>&1 &
              break
              ;;
          "Update/scan MPD"*,*|*,"Update/scan MPD"*)
              mpc update --quiet &
              break
              ;;
          "View Music Service Log"*,*|*,"View Music Service Log"*)
              clear
              printf "\n"
              show_logs_menu
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
      REPLY=
    done
  done
  init_vars
}

show_fzmp_menu() {
  while true
  do
    FIG_TEXT="Fuzzy Search"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=()
    [ "${have_fzf}" ] && options+=("Search all songs in library")
    [ "${have_fzf}" ] && options+=("Search artist/album with fzf")
    [ "${have_dmenu}" ] && options+=("Search artist/album with dmenu")
    [ "${have_fzf}" ] && options+=("List genres in library")
    [ "${have_fzf}" ] && options+=("Search current playlist")
    [ "${have_fzf}" ] && options+=("List saved playlists")
    options+=("Main menu" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              break
              ;;
          "Main menu",*|*,"Main menu"|"Back",*|*,"Back"|"back",*|*,"back")
              clear
              printf "\n"
              init_vars
              show_main_menu
              break 2
              ;;
          "Search artist/album with fzf",*|*,"Search artist/album with fzf")
              fzmp -a
              break
              ;;
          "Search artist/album with dmenu",*|*,"Search artist/album with dmenu")
              [ -x ${SCRIPTS}/mpdmenu.sh ] && ${SCRIPTS}/mpdmenu.sh
              break
              ;;
          "Search all"*,*|*,"Search all"*)
              fzmp -A
              break
              ;;
          "List genre"*,*|*,"List genre"*)
              fzmp -g
              break
              ;;
          "Search current"*,*|*,"Search current"*)
              fzmp -p
              break
              ;;
          "List saved"*,*|*,"List saved"*)
              fzmp -P
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
    done
  done
}

show_ascii_menu() {
  while true
  do
    FIG_TEXT="Asciimatics"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    SPLASH=1
    if [ "${AUDIO}" ]
    then
      audiostat="ON"
    else
      audiostat="OFF"
    fi
    if [ "${RECORD}" ]
    then
      recordstat="ON"
    else
      recordstat="OFF"
    fi
    if [ "${USE_TMUX}" ]
    then
      usetmux="ON"
    else
      usetmux="OFF"
    fi
    skip_it_so=
    save_it_so=
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=("Julia Set ASCIImatics Animation" "MPPlus ASCIImatics Animation" "Plasma ASCIImatics Animation" "Toggle Audio (${audiostat})")
    [ "${have_nema}" ] && options+=("Toggle Record Tmux Session (${recordstat})")
    options+=("Toggle Use Tmux (${usetmux})")
    [ "${have_ascii}" ] && options+=("Asciiville Menu")
    options+=("Main menu" "Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              skip_it_so=1
              break
              ;;
          "Main menu",*|*,"Main menu"|"Back",*|*,"Back"|"back",*|*,"back")
              clear
              printf "\n"
              init_vars
              show_main_menu
              break 2
              ;;
          "Julia Set ASCIImatics Animation",*|*,"Julia Set ASCIImatics Animation")
              MPPSPLASH="${MPPSPLASH} -j"
              MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l julia"
              break
              ;;
          "MPPlus ASCIImatics Animation",*|*,"MPPlus ASCIImatics Animation")
              MPPSPLASH="${MPPSPLASH} -m"
              MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l rocks"
              break
              ;;
          "Plasma ASCIImatics Animation",*|*,"Plasma ASCIImatics Animation")
              MPPSPLASH="${MPPSPLASH} -p"
              MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l plasma"
              break
              ;;
          "Toggle Audio"*,*|*,"Toggle Audio"*)
              if [ "${AUDIO}" ]
              then
                AUDIO=
              else
                AUDIO=1
              fi
              if [ "${AUDIO}" ]
              then
                MPPSPLASH="${MPPSPLASH} -a"
                MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -a"
              else
                MPPSPLASH=`echo ${MPPSPLASH} | sed -e "s/ -a//"`
                MPPSPLASH_TMUX=`echo ${MPPSPLASH_TMUX} | sed -e "s/ -a//"`
              fi
              save_it_so=1
              skip_it_so=1
              break
              ;;
          "Toggle Record Tmux Session"*,*|*,"Toggle Record Tmux Session"*)
              if [ "${RECORD}" ]
              then
                RECORD=
              else
                RECORD=1
                USE_TMUX=1
              fi
              if [ "${RECORD}" ]
              then
                MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -R"
              else
                MPPSPLASH_TMUX=`echo ${MPPSPLASH_TMUX} | sed -e "s/ -R//"`
              fi
              skip_it_so=1
              break
              ;;
          "Toggle Use Tmux"*,*|*,"Toggle Use Tmux"*)
              if [ "${USE_TMUX}" ]
              then
                USE_TMUX=
                RECORD=
              else
                USE_TMUX=1
              fi
              save_it_so=1
              skip_it_so=1
              break
              ;;
          "Asciiville"*,*|*,"Asciiville"*)
              clear
              asciiville
              clear
              skip_it_so=1
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
      REPLY=
    done
    [ "${save_it_so}" ] && {
      save_config
    }
    [ "${skip_it_so}" ] || {
      make_it_so
      init_vars
    }
  done
  init_vars
}

choose_folder() {
  TMP="$(mktemp)"
  ranger --choosedir="${TMP}" "${HOME}" 1>&2
  cat ${TMP}
  rm  -f ${TMP}
}

select_music_dir() {
  if [ "${have_ranger}" ]
  then
    echo ""
    echo "Choosing the music directory in Ranger is done by visiting a directory"
    echo ""
    echo "Use the arrow keys to browse folders"
    echo "Press 'Enter' to enter a directory"
    echo "Create a new directory with ':mkdir <dirname>'"
    echo ""
    echo "While in the directory you wish to select, quit Ranger with 'q'"
    echo ""
    while true
    do
      read -p "Select music directory now? (y/n) " answer
      case ${answer} in
        [Yy]* )
          MUSIC_DIR="$(choose_folder)"
          echo ""
          echo "Selected music directory = ${MUSIC_DIR}"
          echo ""
          break
          ;;
        [Nn]* )
          printf "\nSkipping music directory selection.\n"
          break
          ;;
        * ) echo "Please answer 'y' to select directory, or 'n' to skip."
          ;;
      esac
    done
  else
    MUSIC_DIR=$(dialog --stdout \
                          --title "Please select a music folder" \
                          --fselect ${HOME} 14 48)
  fi
}

show_main_menu() {
  clear
  printf "\n"
  while true
  do
    if [ "${FULLSCREEN}" ]
    then
      fullstat="ON"
    else
      fullstat="OFF"
    fi
    if [ "${RECORD}" ]
    then
      recordstat="ON"
    else
      recordstat="OFF"
    fi
    if [ "${COVER_ART}" ]
    then
      coverstat="ON"
    else
      coverstat="OFF"
    fi
    if [ "${USE_TMUX}" ]
    then
      usetmux="ON"
    else
      usetmux="OFF"
    fi
    skip_it_so=
    save_it_so=
    FIG_TEXT="Main Menu"
    if [ "${use_figlet}" ]
    then
      select_font small
      show_figlet
    else
      show_menu_title "${FIG_TEXT}"
    fi
    PS3="${BOLD}${PLEASE} command choice (numeric or text, 'h' for help): ${NORM}"
    options=("Launch mpcplus in Current")
    [ "${have_kitty}" ] && options+=("Launch mpcplus with Kitty")
    [ "${have_gnome}" ] && options+=("Launch mpcplus with Gnome")
    [ "${have_retro}" ] && options+=("Launch mpcplus with Retro")
    [ "${have_simple}" ] && options+=("Launch mpcplus with Simple")
    [ "${have_tilix}" ] && options+=("Launch mpcplus with Tilix")
    [ "${have_cantata}" ] && options+=("Cantata Music Player Plus")
    [ "${need_yams}" ] && options+=("Activate Last.fm Scrobbler")
    options+=("ASCIImatics Animations")
    options+=("Convert M4A files to MP3" "Convert WAV files to MP3")
    options+=("Import Music to Beets")
    options+=("Fetch Lyrics" "Blissify Audio Info Extraction")
    options+=("Essentia Audio Info Extraction")
    options+=("AcousticBrainz Info Retrieval")
    options+=("Manage Music Downloads")
    options+=("Manage Music Services")
    options+=("View Music Service Logs")
    [ "${have_fzf}" ] && is_running mpd && options+=("List/Search/Select Media")
    options+=("Select Music Directory")
    [ "${have_uebz}" ] && options+=("Toggle Show Cover Art (${coverstat})")
    options+=("Toggle Use Tmux (${usetmux})")
    [ "${have_nema}" ] && options+=("Toggle Record Tmux Session (${recordstat})")
    options+=("Toggle Fullscreen (${fullstat})")
    [ "${have_mirror}" ] && options+=("MagicMirror Command Menu")
    [ "${have_roon}" ] && options+=("RoonCommandLine Menu")
    options+=("Quit")
    select opt in "${options[@]}"
    do
      case "$opt,$REPLY" in
          "h",*|*,"h"|"H",*|*,"H"|"help",*|*,"help"|"Help",*|*,"Help")
              clear
              printf "\n"
              show_help_menu
              skip_it_so=1
              break
              ;;
          "Launch mpcplus in Current",*|*,"Launch mpcplus in Current")
              MPCPLUS="mpcplus"
              TMUX_MPC=1
              USE_TMUX=1
              CURRENT=1
              break
              ;;
          "Launch mpcplus with Kitty",*|*,"Launch mpcplus with Kitty")
              MPCPLUS="mpcplus"
              KITTY=1
              break
              ;;
          "Launch mpcplus with Gnome",*|*,"Launch mpcplus with Gnome")
              MPCPLUS="mpcplus"
              GNOME=1
              break
              ;;
          "Launch mpcplus with Retro",*|*,"Launch mpcplus with Retro")
              MPCPLUS="mpcplus"
              RETRO=1
              break
              ;;
          "Launch mpcplus with Simple",*|*,"Launch mpcplus with Simple")
              MPCPLUS="mpcplus"
              SIMPLE=1
              break
              ;;
          "Launch mpcplus with Tilix",*|*,"Launch mpcplus with Tilix")
              MPCPLUS="mpcplus"
              TILIX=1
              break
              ;;
          "Cantata Music Player Plus",*|*,"Cantata Music Player Plus")
              MPCPLUS="cantata"
              break
              ;;
          "ASCIImatics Animations",*|*,"ASCIImatics Animations")
              clear
              printf "\n"
              show_ascii_menu
              skip_it_so=1
              break
              ;;
          "Manage Music Downloads"*,*|*,"Manage Music Downloads"*)
              clear
              printf "\n"
              show_downloads_menu
              skip_it_so=1
              break
              ;;
          "Manage Music Services"*,*|*,"Manage Music Services"*)
              clear
              printf "\n"
              show_services_menu
              skip_it_so=1
              break
              ;;
          "View Music Service Log"*,*|*,"View Music Service Log"*)
              clear
              printf "\n"
              show_logs_menu
              skip_it_so=1
              break
              ;;
          "List"*,*|*,"List"*)
              clear
              printf "\n"
              show_fzmp_menu
              skip_it_so=1
              break
              ;;
          "Select Music"*,*|*,"Select Music"*)
              CUR_MUS_DIR="${MUSIC_DIR}"
              select_music_dir
              [ "${CUR_MUS_DIR}" == "${MUSIC_DIR}" ] || {
                save_config
                mppinit sync
              }
              skip_it_so=1
              break
              ;;
          "Convert M4A"*,*|*,"Convert M4A"*)
              CONVERT_M4A=1
              break
              ;;
          "Convert WAV"*,*|*,"Convert WAV"*)
              CONVERT_WAV=1
              break
              ;;
          "Activate"*,*|*,"Activate"*)
              ACT_YAMS=1
              break
              ;;
          "Blissify"*,*|*,"Blissify"*)
              BLISSIFY=1
              break
              ;;
          "Essentia"*,*|*,"Essentia"*)
              XTRACTOR="all"
              break
              ;;
          "AcousticBrainz"*,*|*,"AcousticBrainz"*)
              ACBRAINZ="all"
              break
              ;;
          "Fetch"*,*|*,"Fetch"*)
              FETCH_LYRICS=1
              break
              ;;
          "Import"*,*|*,"Import"*)
              BEETS_IMPORT=1
              break
              ;;
          "Toggle Show Cover Art"*,*|*,"Toggle Show Cover Art"*)
              if [ "${COVER_ART}" ]
              then
                COVER_ART=
              else
                COVER_ART=1
              fi
              if [ "${COVER_ART}" ]
              then
                TMUX_MPC=1
                MPCPLUS_TMUX=`echo ${MPCPLUS_TMUX} | sed -e "s/ -A//"`
              else
                TMUX_MPC=
                MPCPLUS_TMUX="${MPCPLUS_TMUX} -A"
              fi
              save_it_so=1
              skip_it_so=1
              break
              ;;
          "Toggle Use Tmux"*,*|*,"Toggle Use Tmux"*)
              if [ "${USE_TMUX}" ]
              then
                USE_TMUX=
                RECORD=
              else
                USE_TMUX=1
              fi
              save_it_so=1
              skip_it_so=1
              break
              ;;
          "Toggle Record Tmux Session"*,*|*,"Toggle Record Tmux Session"*)
              if [ "${RECORD}" ]
              then
                RECORD=
              else
                RECORD=1
                USE_TMUX=1
              fi
              if [ "${RECORD}" ]
              then
                MPCPLUS_TMUX="${MPCPLUS_TMUX} -r"
              else
                MPCPLUS_TMUX=`echo ${MPCPLUS_TMUX} | sed -e "s/ -r//"`
              fi
              skip_it_so=1
              break
              ;;
          "Toggle Fullscreen"*,*|*,"Toggle Fullscreen"*)
              if [ "${FULLSCREEN}" ]
              then
                FULLSCREEN=
              else
                FULLSCREEN=1
              fi
              save_it_so=1
              skip_it_so=1
              break
              ;;
          "MagicMirror"*,*|*,"MagicMirror"*)
              clear
              FIG_TEXT="Mirror Command"
              if [ "${use_figlet}" ]
              then
                select_font small
                show_figlet
              else
                show_menu_title "${FIG_TEXT}"
              fi
              mirror
              clear
              skip_it_so=1
              break
              ;;
          "RoonCommandLine"*,*|*,"RoonCommandLine"*)
              clear
              FIG_TEXT="Roon Command"
              if [ "${use_figlet}" ]
              then
                select_font small
                show_figlet
              else
                show_menu_title "${FIG_TEXT}"
              fi
              roon
              clear
              skip_it_so=1
              break
              ;;
          "Quit",*|*,"Quit"|"quit",*|*,"quit")
              printf "\nExiting\n"
              exit 0
              ;;
      esac
      REPLY=
    done
    [ "${save_it_so}" ] && {
      save_config
    }
    [ "${skip_it_so}" ] || {
      make_it_so
      init_vars
    }
  done
}

init_vars() {
  MPCPLUS="mpcplus"
  if [ "${USE_GRAD}" ]
  then
    MPCPLUS_TMUX="mpcplus-tmux"
  else
    MPCPLUS_TMUX="mpcplus-tmux -g"
  fi
  MPPSPLASH="mppsplash"
  MPPSPLASH_TMUX="mppsplash-tmux"

  CLIENT=
  CONVERT_WAV=
  CONVERT_M4A=
  DOWNLOAD_ART=
  DOWNLOAD_BANDCAMP=
  DOWNLOAD_SOUNDCLOUD=
  DOWNLOAD_YOUTUBE=
  LIST_YT_PLAYLISTS=
  LIST_YT_UPLOADS=
  LIST_YT_URL=
  DL_URL=
  YT_USER=
  ACT_YAMS=
  DIS_YAMS=
  FETCH_LYRICS=
  BEETS_IMPORT=
  ACBRAINZ=
  BLISSIFY=
  XTRACTOR=
  HALFHEIGHT=
  INTERACTIVE=
  FZMPOPT=
  MUSIC_DIRECTORY=
  QRTRHEIGHT=
  RECORD=
  SPLASH=
  TMUX_SPLASH=
  USAGE=
}

save_config() {
  echo "## MusicPlayerPlus runtime configuration" > ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "#  After modifying any of the following settings, run the command:" >> ${MPPCONF}
  echo "#    mppinit sync" >> ${MPPCONF}
  echo "#  as your normal MusicPlayerPlus user" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "## Music library location" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "MUSIC_DIR=\"${MUSIC_DIR}\"" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "## General settings" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "# To enable any of these, set to 1" >> ${MPPCONF}
  echo "# For example, to enable cover art display in tmux sessions set COVER_ART=1" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "# Play audio during asciimatics animations" >> ${MPPCONF}
  echo "AUDIO=${AUDIO}" >> ${MPPCONF}
  echo "# Display cover art in tmux sessions" >> ${MPPCONF}
  echo "COVER_ART=${COVER_ART}" >> ${MPPCONF}
  echo "# Display mpcplus and mppcava in a tmux session" >> ${MPPCONF}
  echo "USE_TMUX=${USE_TMUX}" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "## Terminal emulator preference" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "#  Can be one of: console, current, gnome, kitty, retro, simple, tilix" >> ${MPPCONF}
  echo "#  Where:" >> ${MPPCONF}
  echo "#    'console' will force a tmux session" >> ${MPPCONF}
  echo "#    'current' will force a tmux session in the current terminal window" >> ${MPPCONF}
  echo "#    'gnome' will use the gnome-terminal emulator if installed" >> ${MPPCONF}
  echo "#    'kitty' will use the Kitty terminal emulator if installed" >> ${MPPCONF}
  echo "#    'retro' will use cool-retro-term if installed" >> ${MPPCONF}
  echo "#    'simple' will use the ST terminal emulator if installed" >> ${MPPCONF}
  echo "#    'tilix' will use the Tilix terminal emulator if installed" >> ${MPPCONF}
  echo "#  Default fallback if none specified or not available is Kitty" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "#  Uncomment the preferred mode" >> ${MPPCONF}
  if [ "${CONSOLE_MODE}" ]
  then
    echo "MPP_MODE=console" >> ${MPPCONF}
    echo "#MPP_MODE=current" >> ${MPPCONF}
    echo "#MPP_MODE=gnome" >> ${MPPCONF}
    echo "#MPP_MODE=retro" >> ${MPPCONF}
    echo "#MPP_MODE=simple" >> ${MPPCONF}
    echo "#MPP_MODE=tilix" >> ${MPPCONF}
    echo "#MPP_MODE=kitty" >> ${MPPCONF}
  else
    echo "#MPP_MODE=console" >> ${MPPCONF}
    if [ "${CURRENT}" ]
    then
      echo "MPP_MODE=current" >> ${MPPCONF}
      echo "#MPP_MODE=gnome" >> ${MPPCONF}
      echo "#MPP_MODE=retro" >> ${MPPCONF}
      echo "#MPP_MODE=simple" >> ${MPPCONF}
      echo "#MPP_MODE=tilix" >> ${MPPCONF}
      echo "#MPP_MODE=kitty" >> ${MPPCONF}
    else
      echo "#MPP_MODE=current" >> ${MPPCONF}
      if [ "${GNOME}" ]
      then
        echo "MPP_MODE=gnome" >> ${MPPCONF}
        echo "#MPP_MODE=retro" >> ${MPPCONF}
        echo "#MPP_MODE=simple" >> ${MPPCONF}
        echo "#MPP_MODE=tilix" >> ${MPPCONF}
        echo "#MPP_MODE=kitty" >> ${MPPCONF}
      else
        echo "#MPP_MODE=gnome" >> ${MPPCONF}
        if [ "${RETRO}" ]
        then
          echo "MPP_MODE=retro" >> ${MPPCONF}
          echo "#MPP_MODE=simple" >> ${MPPCONF}
          echo "#MPP_MODE=tilix" >> ${MPPCONF}
          echo "#MPP_MODE=kitty" >> ${MPPCONF}
        else
          echo "#MPP_MODE=retro" >> ${MPPCONF}
          if [ "${SIMPLE}" ]
          then
            echo "MPP_MODE=simple" >> ${MPPCONF}
            echo "#MPP_MODE=tilix" >> ${MPPCONF}
            echo "#MPP_MODE=kitty" >> ${MPPCONF}
          else
            echo "#MPP_MODE=simple" >> ${MPPCONF}
            if [ "${TILIX}" ]
            then
              echo "MPP_MODE=tilix" >> ${MPPCONF}
              echo "#MPP_MODE=kitty" >> ${MPPCONF}
            else
              echo "#MPP_MODE=tilix" >> ${MPPCONF}
              if [ "${KITTY}" ]
              then
                echo "MPP_MODE=kitty" >> ${MPPCONF}
              else
                echo "#MPP_MODE=kitty" >> ${MPPCONF}
              fi
            fi
          fi
        fi
      fi
    fi
  fi

  echo "" >> ${MPPCONF}
  echo "## Service access" >> ${MPPCONF}
  echo "#" >> ${MPPCONF}
  echo "# The Bandcamp username can be found by visiting Bandcamp 'Settings' -> 'Fan'" >> ${MPPCONF}
  echo "# If you do not have a Bandcamp account, leave blank" >> ${MPPCONF}
  echo "BANDCAMP_USER=${BANDCAMP_USER}" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "# Your Last.fm username, api key, and api secret" >> ${MPPCONF}
  echo "# If you do not have a Last.fm account, leave blank" >> ${MPPCONF}
  echo "LASTFM_USER=${LASTFM_USER}" >> ${MPPCONF}
  echo "LASTFM_APIKEY=${LASTFM_APIKEY}" >> ${MPPCONF}
  echo "LASTFM_SECRET=${LASTFM_SECRET}" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "# The Soundcloud user slug can be found by logging in to Soundcloud" >> ${MPPCONF}
  echo "# click on the username at top right then 'Profile'. The user slug" >> ${MPPCONF}
  echo "# is the last component of the URL when viewing your Soundcloud Profile." >> ${MPPCONF}
  echo "# If you do not have a Soundcloud account, leave blank" >> ${MPPCONF}
  echo "SOUNDCLOUD_SLUG=${SOUNDCLOUD_SLUG}" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "# Your Spotify client id and client secret" >> ${MPPCONF}
  echo "# If you do not have a Spotify account, leave blank" >> ${MPPCONF}
  echo "SPOTIFY_CLIENT=${SPOTIFY_CLIENT}" >> ${MPPCONF}
  echo "SPOTIFY_SECRET=${SPOTIFY_SECRET}" >> ${MPPCONF}
  echo "" >> ${MPPCONF}
  echo "# Your YouTube api key" >> ${MPPCONF}
  echo "# If you do not have a YouTube account, leave blank" >> ${MPPCONF}
  echo "YOUTUBE_APIKEY=${YOUTUBE_APIKEY}" >> ${MPPCONF}
  chmod 600 ${MPPCONF}
}

set_user_conf() {
  exitcode=$?
  save_config
  exit ${exitcode}
}

pathadd() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1${PATH:+":$PATH"}"
  fi
}

pathadd "/usr/local/bin"
pathadd "${HOME}/.local/bin"
export PATH

# Check if initialization has been run
if [ -f ${HOME}/.config/mpcplus/config ]
then
  [ -f ${MPPCONF} ] || save_config
else
  echo ""
  echo "MusicPlayerPlus initialization needs to be run once."
  echo "Answer 'y' to initialize, or 'n' to skip it for now."
  echo ""
  while true
  do
    read -p "Initialize MusicPlayerPlus now [y/n] " answer
    case ${answer} in
      [Yy]* )
        mppinit
        break
        ;;
      [Nn]* )
        printf "\nSkipping initialization.\n"
        printf "\nInitialize MusicPlayerPlus with the command 'mppinit'\n"
        read -p "Press Enter to continue" contans
        break
        ;;
      * ) echo "Please answer 'y' to initialize, or 'n' to skip."
        ;;
    esac
  done
fi

have_beet=`type -p beet`
have_wmctrl=`type -p wmctrl`
have_xprop=`type -p xprop`
have_xrandr=`type -p xrandr`
have_xdpy=`type -p xdpyinfo`
have_cantata=`type -p cantata`
have_gnome=`type -p gnome-terminal`
have_retro=`type -p cool-retro-term`
have_simple=`type -p st`
have_tilix=`type -p tilix`
have_kitty=`type -p kitty`

init_vars
AUDIO=
COVER_ART=
FULLSCREEN=
CURRENT=
GNOME=
KITTY=
RETRO=
SIMPLE=
TILIX=
TMUX_MPC=
USE_TMUX=

# Retrieve user preferences
[ -f ${MPPCONF} ] && . ${MPPCONF}
case "${MPP_MODE}" in
  console)
    if [ "${DISPLAY}" ]
    then
      consolemode=
      # Check if on a console screen
      have_tty=`type -p tty`
      [ "${have_tty}" ] && {
        tty=$(tty)
        echo "${tty}" | grep /dev/tty > /dev/null && consolemode=1
        echo "${tty}" | grep /dev/con > /dev/null && consolemode=1
      }
      [ "${consolemode}" ] || {
        # Check if this is an SSH session
        [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] && consolemode=1
      }
      if [ "${consolemode}" ]
      then
        CONSOLE_MODE=1
        TMUX_MPC=1
        USE_TMUX=1
      else
        pick_terminal || {
          CONSOLE_MODE=1
          TMUX_MPC=1
          USE_TMUX=1
        }
      fi
    else
      CONSOLE_MODE=1
      TMUX_MPC=1
      USE_TMUX=1
    fi
    ;;
  current)
    TMUX_MPC=1
    USE_TMUX=1
    CURRENT=1
    ;;
  gnome)
    GNOME=1
    [ "${have_gnome}" ] || {
      KITTY=1
      GNOME=
    }
    ;;
  kitty)
    KITTY=1
    ;;
  retro)
    RETRO=1
    [ "${have_retro}" ] || {
      KITTY=1
      RETRO=
    }
    ;;
  simple)
    SIMPLE=1
    [ "${have_simple}" ] || {
      KITTY=1
      SIMPLE=
    }
    ;;
  tilix)
    TILIX=1
    [ "${have_tilix}" ] || {
      KITTY=1
      TILIX=
    }
    ;;
  *)
    KITTY=1
    ;;
esac

# Check if the window manager supports move/resize and DISPLAY can be opened
if [ "${DISPLAY}" ]
then
  movewindow=
  hasopacity=
  consolemode=
  # First check if on a console screen
  have_tty=`type -p tty`
  [ "${have_tty}" ] && {
    tty=$(tty)
    echo "${tty}" | grep /dev/tty > /dev/null && consolemode=1
    echo "${tty}" | grep /dev/con > /dev/null && consolemode=1
  }
  # Next check if this is an SSH session
  [ "${consolemode}" ] || {
    # Check if this is an SSH session
    [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] && consolemode=1
  }
  if [ "${consolemode}" ]
  then
    CONSOLE_MODE=1
    USE_EWMH=
    USE_OPAC=
    USE_TMUX=1
  else
    # Check window manager's supported hints
    if [ "${have_xprop}" ]
    then
      hints=`xprop -root -notype | grep ^_NET_SUPPORTED`
      echo "${hints}" | grep _NET_MOVERESIZE_WINDOW > /dev/null && movewindow=1
      echo "${hints}" | grep _NET_WM_WINDOW_OPACITY > /dev/null && hasopacity=1
      if [ "${movewindow}" ]
      then
        USE_EWMH=1
      else
        USE_EWMH=
        CONSOLE_MODE=1
        USE_TMUX=1
      fi
      if [ "${hasopacity}" ]
      then
        USE_OPAC=1
      else
        USE_OPAC=
      fi
    else
      status=0
      if [ -x ${SCRIPTS}/check_tty.sh ]
      then
        ${SCRIPTS}/check_tty.sh
        status=$?
      else
        if [ "${have_xdpy}" ]
        then
          xdpyinfo -display "${DISPLAY}" > /dev/null 2>&1
          status=$?
        else
          if [ "${have_kitty}" ]
          then
            kitty echo "" > /dev/null 2>&1
            status=$?
          else
            [ "${have_gnome}" ] && {
              gnome-terminal --quiet -- echo "" > /dev/null 2>&1
              status=$?
            }
          fi
        fi
      fi
      if [ ${status} -eq 0 ]
      then
        USE_EWMH=1
        USE_OPAC=1
      else
        CONSOLE_MODE=1
        USE_EWMH=
        USE_OPAC=
        USE_TMUX=1
      fi
    fi
  fi
else
  CONSOLE_MODE=1
  USE_EWMH=
  USE_OPAC=
  USE_TMUX=1
fi

systemctl --user is-active --quiet yams.service
if [ $? -eq 0 ]
then
  need_yams=
else
  systemctl --user is-enabled --quiet yams.service
  if [ $? -eq 0 ]
  then
    need_yams=
  else
    need_yams=1
  fi
fi

if [ "${CONSOLE_MODE}" ]
then
  have_cantata=
  have_gnome=
  have_retro=
  have_tilix=
  have_simple=
  have_kitty=
  s_wid=1920
  s_hit=1080
else
  [ "${have_xrandr}" ] && {
    read -r s_wid s_hit < <(xrandr | grep current | \
            awk -F ',' '{ print $2 }' | awk '{ print $2, $4 }')
   }
fi
if [ -x /opt/navidrome/navidrome ]
then
  have_navi=1
else
  have_navi=
fi
have_uebz=`type -p ueberzug`
have_dmenu=`type -p dmenu`
have_fzf=`type -p fzf`
have_mpc=`type -p mpc`
have_mopidy=`type -p mopidy`
have_nema=`type -p asciinema`
have_figlet=`type -p figlet`
have_lolcat=`type -p lolcat`
have_lynx=`type -p lynx`
have_w3m=`type -p w3m`
have_ranger=`type -p ranger`
have_ascii=`type -p asciiville`
if [ -d /usr/local/Roon ]
then
  have_roon=`type -p roon`
else
  have_roon=
fi
if [ -d /usr/local/MirrorCommand ]
then
  have_mirror=`type -p mirror`
else
  have_mirror=
fi
writeflag=
tagflag=
disable_ewmh=

if [ "${have_figlet}" ]
then
  use_figlet=1
  [ -d "${FIG_FONTS}" ] || {
    DEF_FIG_FONTS=`figlet -I2`
    if [ -d "${DEF_FIG_FONTS}" ]
    then
      FIG_FONTS="${DEF_FIG_FONTS}"
    else
      use_figlet=
    fi
  }
else
  use_figlet=
fi

USE_MPCPLUS=1
while getopts "AabBcC:D:d:eEFfGghHiIjJkKLmM:n:NpP:qrRSs:tT:Uv:wWx:X:yYz:u" flag
do
  case $flag in
    a)
      AUDIO=1
      MPPSPLASH="${MPPSPLASH} -a"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -a"
      tagflag="-a"
      ;;
    A)
      [ "${have_uebz}" ] && COVER_ART=1
      tagflag="-A"
      ;;
    b)
      MPPSPLASH="${MPPSPLASH} -b"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -b"
      ;;
    B)
      BLISSIFY=1
      ;;
    c)
      TMUX_MPC=1
      USE_TMUX=1
      CURRENT=1
      MPP_MODE=current
      GNOME=
      KITTY=
      RETRO=
      SIMPLE=
      TILIX=
      ;;
    C)
      CLIENT="${OPTARG}"
      type -p "${CLIENT}" > /dev/null || {
        echo "Option '-C' indicates use ${CLIENT} MPD client."
        echo "However, ${CLIENT} is not installed or not in your path."
        echo "You may be able to install ${CLIENT} as follows:"
        printf "\n\n\tsudo apt install ${CLIENT}\nor"
        printf "\n\tsudo pacman -S ${CLIENT}\nor"
        printf "\n\tsudo dnf install ${CLIENT}\n\n"
        if [ "${have_cantata}" ]
        then
          echo "Continuing, using cantata rather than ${CLIENT}."
          CLIENT=cantata
        else
          echo "Continuing, using mpcplus rather than ${CLIENT}."
          CLIENT=
        fi
      }
      [ "${CLIENT}" ] && {
        MPCPLUS="${CLIENT}"
        USE_MPCPLUS=
      }
      ;;
    D)
      case "${OPTARG}" in
        Art|art|Album|album|Albumart|albumart)
          DOWNLOAD_ART=1
          ;;
        Bandcamp|bandcamp)
          DOWNLOAD_BANDCAMP=1
          ;;
        Soundcloud|soundcloud)
          DOWNLOAD_SOUNDCLOUD=1
          ;;
        *)
          DOWNLOAD_YOUTUBE=1
          DL_URL="${OPTARG}"
          ;;
      esac
      ;;
    d)
      MUSIC_DIRECTORY="${OPTARG}"
      ;;
    E)
      USE_GRAD=
      ;;
    e)
      SIMPLE=1
      MPP_MODE=simple
      CURRENT=
      GNOME=
      KITTY=
      RETRO=
      TILIX=
      [ "${have_simple}" ] || {
        echo "Option '-e' indicates use simple terminal emulator."
        echo "However, st is not installed, unavailable, or not in your path."
        echo "You can install st using apt, pacman, or dnf as follows:"
        printf "\n\n\tsudo apt install stterm\nor"
        printf "\n\tsudo pacman -S stterm\nor"
        printf "\n\tsudo dnf install stterm\n\n"
        echo "Proceeding with Kitty terminal emulator"
        KITTY=1
        MPP_MODE=kitty
        TILIX=
      }
      ;;
    F)
      CONVERT_WAV=1
      ;;
    f)
      FULLSCREEN=1
      ;;
    G)
      CONVERT_M4A=1
      ;;
    g)
      GNOME=1
      MPP_MODE=gnome
      CURRENT=
      KITTY=
      RETRO=
      SIMPLE=
      TILIX=
      [ "${have_gnome}" ] || {
        echo "Option '-g' indicates use gnome-terminal emulator."
        echo "However, gnome-terminal is not installed or not in your path."
        echo "You can install gnome-terminal using apt, pacman, or dnf:"
        printf "\n\n\tsudo apt install gnome-terminal\nor"
        printf "\n\tsudo pacman -S gnome-terminal\nor"
        printf "\n\tsudo dnf install gnome-terminal\n\n"
        echo "Proceeding with Kitty terminal emulator"
        KITTY=1
        MPP_MODE=kitty
        GNOME=
      }
      ;;
    H)
      disable_ewmh=1
      ;;
    h)
      HALFHEIGHT=1
      ;;
    I)
      BEETS_IMPORT=1
      ;;
    i)
      INTERACTIVE=1
      ;;
    j)
      MPPSPLASH="${MPPSPLASH} -j"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l julia"
      ;;
    J)
      MPPSPLASH="${MPPSPLASH} -J"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -J"
      ;;
    K)
      kill_tmux_sessions
      exit 0
      ;;
    k)
      KITTY=1
      MPP_MODE=kitty
      GNOME=
      CURRENT=
      RETRO=
      SIMPLE=
      TILIX=
      [ "${have_kitty}" ] || {
        echo "Option '-k' indicates use Kitty terminal emulator."
        echo "However, kitty is not installed or not in your path."
        echo "Proceeding with current terminal emulator"
        KITTY=
        CURRENT=1
        MPP_MODE=current
        TMUX_MPC=1
        USE_TMUX=1
      }
      ;;
    L)
      FETCH_LYRICS=1
      ;;
    m)
      MPPSPLASH="${MPPSPLASH} -m"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l rocks"
      ;;
    M)
      mpp_service ${OPTARG} mpd
      echo "Exiting"
      exit 0
      ;;
    n)
      MPPSPLASH="${MPPSPLASH} -c ${OPTARG}"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -c ${OPTARG}"
      ;;
    N)
      MPPSPLASH="${MPPSPLASH} -C"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -t"
      ;;
    p)
      MPPSPLASH="${MPPSPLASH} -p"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l plasma"
      ;;
    P)
      MPCPLUS_TMUX="${MPCPLUS_TMUX} -p ${OPTARG}"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -l ${OPTARG}"
      ;;
    q)
      QRTRHEIGHT=1
      ;;
    r)
      RETRO=1
      MPP_MODE=retro
      CURRENT=
      GNOME=
      KITTY=
      SIMPLE=
      TILIX=
      [ "${have_retro}" ] || {
        echo "Option '-r' indicates use cool-retro-term terminal emulator."
        echo "However, cool-retro-term is not installed or not in your path."
        echo "You can install cool-retro-term using apt, pacman, or dnf:"
        printf "\n\n\tsudo apt install cool-retro-term\nor"
        printf "\n\tsudo pacman -S cool-retro-term\nor"
        printf "\n\tsudo dnf install cool-retro-term\n\n"
        echo "Proceeding with Kitty"
        KITTY=1
        MPP_MODE=kitty
        RETRO=
      }
      ;;
    R)
      [ "${have_nema}" ] && {
        RECORD=1
        USE_TMUX=1
        MPCPLUS_TMUX="${MPCPLUS_TMUX} -r"
        MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -R"
      }
      ;;
    S)
      SPLASH=1
      ;;
    s)
      MPPSPLASH="${MPPSPLASH} -s ${OPTARG}"
      MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -s ${OPTARG}"
      ;;
    t)
      TILIX=1
      MPP_MODE=tilix
      CURRENT=
      GNOME=
      KITTY=
      RETRO=
      SIMPLE=
      [ "${have_tilix}" ] || {
        echo "Option '-t' indicates use tilix terminal emulator."
        echo "However, tilix is not installed, unavailable, or not in your path."
        echo "You can install tilix using apt, pacman, or dnf as follows:"
        printf "\n\n\tsudo apt install tilix\nor"
        printf "\n\tsudo pacman -S tilix\nor"
        printf "\n\tsudo dnf install tilix\n\n"
        echo "Proceeding with Kitty terminal emulator"
        KITTY=1
        MPP_MODE=kitty
        TILIX=
      }
      ;;
    T)
      tmux_onoff=`echo "${OPTARG}" | tr '[:upper:]' '[:lower:]'`
      if [ "${tmux_onoff}" == "on" ]
      then
        USE_TMUX=1
      else
        if [ "${tmux_onoff}" == "off" ]
        then
          USE_TMUX=
        else
          echo "Invalid argument to -T option: ${OPTARG}"
          usage
        fi
      fi
      ;;
    U)
      MPCPLUS_TMUX="${MPCPLUS_TMUX} -a"
      ;;
    v)
      viz_com=`echo "${OPTARG}" | awk ' { print $1 } '`
      have_viz=`type -p ${viz_com}`
      if [ "${have_viz}" ]
      then
        VISUALIZER="${OPTARG}"
      else
        echo "Specified visualizer ${OPTARG} not found."
        echo "Using ${VISUALIZER} visualizer"
      fi
      ;;
    w)
      writeflag="-w"
      ;;
    W)
      writeflag="-W"
      ;;
    x)
      ACBRAINZ="${OPTARG}"
      ;;
    X)
      XTRACTOR="${OPTARG}"
      ;;
    y)
      DIS_YAMS=1
      ;;
    Y)
      ACT_YAMS=1
      ;;
    z)
      FZMPOPT="${OPTARG}"
      ;;
    u)
      USAGE=1
      ;;
    esac
done

impflags="${tagflag} ${writeflag}"

save_config
[ "${MPP_MODE}" ] && MPCPLUS_TMUX="${MPCPLUS_TMUX} -m ${MPP_MODE}"

[ "${AUDIO}" ] && {
  MPPSPLASH="${MPPSPLASH} -a"
  MPPSPLASH_TMUX="${MPPSPLASH_TMUX} -a"
}

if [ "${COVER_ART}" ]
then
  TMUX_MPC=1
else
  MPCPLUS_TMUX="${MPCPLUS_TMUX} -A"
fi

# The -T option says use tmux, -S says do asciimatics
# If we have both then do asciimatics in tmux
# If just the -T then do mpcplus in tmux
[ "${USE_TMUX}" ] && {
  if [ "${SPLASH}" ]
  then
    TMUX_SPLASH=1
  else
    TMUX_MPC=1
  fi
}

[ "${CONSOLE_MODE}" ] || {
  [ "${GNOME}" ] || {
    [ "${TILIX}" ] || {
      [ "${RETRO}" ] || {
        [ "${SIMPLE}" ] || {
          if [ "${have_kitty}" ]
          then
            KITTY=1
          else
            echo "No option '-e', '-g', '-t', or '-r' indicates use Kitty"
            echo "terminal emulator. However, Kitty is not installed,"
            echo "unavailable, or not in your path."
            echo "You can install Kitty as follows:"
            printf "\n\n\tmppinit kitty\n\n"
            echo "Alternately, invoke mpplus with the '-t' option to use tilix,"
            echo "the '-g' option to use gnome-terminal, or '-e' to use st."
            pick_terminal || usage
          fi
        }
      }
    }
  }
}

[ "${HALFHEIGHT}" ] && [ "${QRTRHEIGHT}" ] && {
  [ "${FULLSCREEN}" ] && {
    echo "Only one of '-h' and '-q' should be specified"
    echo "Quarter-height overrides half-height. Using quarter-height."
    HALFHEIGHT=
  }
}
[ "${HALFHEIGHT}" ] && {
  [ "${FULLSCREEN}" ] || {
    echo "Height settings only apply when in fullscreen mode."
    echo "Ignoring '-h' half-height option."
    HALFHEIGHT=
  }
}
[ "${QRTRHEIGHT}" ] && {
  [ "${FULLSCREEN}" ] || {
    echo "Height settings only apply when in fullscreen mode."
    echo "Ignoring '-q' quarter-height option."
    QRTRHEIGHT=
  }
}

[ "${USAGE}" ] && usage

if [ "${INTERACTIVE}" ]
then
  DO_NOT_EXIT=1
  trap 'set_user_conf' SIGINT SIGTERM SIGHUP EXIT
  show_main_menu
else
  if [ "${FZMPOPT}" ]
  then
    fzmp -${FZMPOPT}
  else
    make_it_so
  fi
fi
